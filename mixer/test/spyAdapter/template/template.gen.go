// Copyright 2017 Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// THIS FILE IS AUTOMATICALLY GENERATED.

package template

import (
	"context"
	"fmt"
	"net"
	"strings"

	"github.com/gogo/protobuf/proto"

	"istio.io/api/mixer/v1/config/descriptor"
	"istio.io/istio/mixer/pkg/adapter"
	"istio.io/istio/mixer/pkg/attribute"
	"istio.io/istio/mixer/pkg/il/compiled"
	"istio.io/istio/mixer/pkg/log"
	"istio.io/istio/mixer/pkg/template"
	"istio.io/istio/mixer/pkg/template/impl"

	adptTmpl "istio.io/api/mixer/v1/template"
	"istio.io/istio/mixer/pkg/config/proto"

	"istio.io/istio/mixer/test/spyAdapter/template/report"
)

// Add void usages for some imports so that go linter does not complain in case the imports does not get used in the
// below codegen.
var (
	_ net.IP
	_ istio_mixer_v1_config.AttributeManifest
	_ = strings.Reader{}
)

const emptyQuotes = "\"\""

type (
	getFn         func(name string) (value interface{}, found bool)
	namesFn       func() []string
	doneFn        func()
	debugStringFn func() string
	wrapperAttr   struct {
		get         getFn
		names       namesFn
		done        doneFn
		debugString debugStringFn
	}
)

func newWrapperAttrBag(get getFn, names namesFn, done doneFn, debugString debugStringFn) attribute.Bag {
	return &wrapperAttr{
		debugString: debugString,
		done:        done,
		get:         get,
		names:       names,
	}
}

// Get returns an attribute value.
func (w *wrapperAttr) Get(name string) (value interface{}, found bool) {
	return w.get(name)
}

// Names returns the names of all the attributes known to this bag.
func (w *wrapperAttr) Names() []string {
	return w.names()
}

// Done indicates the bag can be reclaimed.
func (w *wrapperAttr) Done() {
	w.done()
}

// DebugString provides a dump of an attribute Bag that avoids affecting the
// calculation of referenced attributes.
func (w *wrapperAttr) DebugString() string {
	return w.debugString()
}

var (
	SupportedTmplInfo = map[string]template.Info{

		samplereport.TemplateName: {
			Name:               samplereport.TemplateName,
			Impl:               "samplereport",
			CtrCfg:             &samplereport.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_REPORT,
			BldrInterfaceName:  samplereport.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: samplereport.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(samplereport.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(samplereport.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {

				var BuildTemplate func(param *samplereport.InstanceParam,
					path string) (*samplereport.Type, error)

				_ = BuildTemplate

				BuildTemplate = func(param *samplereport.InstanceParam,
					path string) (*samplereport.Type, error) {

					if param == nil {
						return nil, nil
					}

					infrdType := &samplereport.Type{}

					var err error = nil

					if param.Value == "" || param.Value == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"Value")
					}
					if infrdType.Value, err = tEvalFn(param.Value); err != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field '%s'; %v", path+"Value", err)
					}

					infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(param.Dimensions))

					for k, v := range param.Dimensions {

						if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {

							return nil, fmt.Errorf("failed to evaluate expression for field '%s'; %v", path+"Dimensions", err)
						}
					}

					return infrdType, err

				}

				instParam := cp.(*samplereport.InstanceParam)

				return BuildTemplate(instParam, "")
			},

			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(samplereport.HandlerBuilder)
				castedTypes := make(map[string]*samplereport.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*samplereport.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetSampleReportTypes(castedTypes)
			},

			ProcessReport: func(ctx context.Context, instances []interface{}, attrs attribute.Bag, handler adapter.Handler) error {

				ins := make([]*samplereport.Instance, len(instances))
				for i, instance := range instances {
					ins[i] = instance.(*samplereport.Instance)
				}

				if err := handler.(samplereport.Handler).HandleSampleReport(ctx, ins); err != nil {
					return fmt.Errorf("failed to report all values: %v", err)
				}
				return nil

			},

			CreateInstanceBuilder: func(instanceName string, param interface{}, expb *compiled.ExpressionBuilder) template.InstanceBuilderFn {

				b, errp := newBuilder_samplereport_Template(expb, param.(*samplereport.InstanceParam))
				if !errp.IsNil() {
					// TODO: This preserves the current semantics of the evaluator, where compilation happens
					// in the evaluation path. Ideally this method should return an error, and we should simply
					// not create an instance builder, in the presence broken config.
					return func(_ attribute.Bag) (interface{}, error) {
						err := errp.AsCompilationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}
				}

				return func(attr attribute.Bag) (interface{}, error) {
					e, errp := b.build(attr)
					if !errp.IsNil() {
						err := errp.AsEvaluationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}

					return e, nil
				}
			},
		},
	}
)

// builder_samplereport_Template builds an instance of Template.
type builder_samplereport_Template struct {
	bldValue compiled.Expression

	bldDimensions map[string]compiled.Expression
} // builder_samplereport_Template

func newBuilder_samplereport_Template(
	expb *compiled.ExpressionBuilder, param *samplereport.InstanceParam) (*builder_samplereport_Template, impl.ErrorPath) {

	if param == nil {
		return nil, impl.ErrorPath{}
	}

	b := &builder_samplereport_Template{}

	var exp compiled.Expression
	_ = exp
	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp

	b.bldValue, err = expb.Compile(param.Value)
	if err != nil {
		return nil, impl.NewErrorPath("Value", err)
	}

	b.bldDimensions = make(map[string]compiled.Expression, len(param.Dimensions))
	for k, v := range param.Dimensions {
		var exp compiled.Expression
		if exp, err = expb.Compile(v); err != nil {
			return nil, impl.NewErrorPath("Dimensions["+k+"].", err)
		}
		b.bldDimensions[k] = exp
	}

	return b, impl.ErrorPath{}
}

func (b *builder_samplereport_Template) build(
	attrs attribute.Bag) (*samplereport.Instance, impl.ErrorPath) {

	if b == nil {
		return nil, impl.ErrorPath{}
	}

	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp
	var iface interface{}
	_ = iface

	r := &samplereport.Instance{}

	if iface, err = b.bldValue.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("Value", err)
	}
	r.Value = iface.(istio_mixer_v1_config_descriptor.ValueType)

	r.Dimensions = make(map[string]interface{}, len(b.bldDimensions))

	for k, v := range b.bldDimensions {
		if iface, err = v.Evaluate(attrs); err != nil {
			return nil, impl.NewErrorPath("Dimensions["+k+"].", err)
		}

		r.Dimensions[k] = iface.(istio_mixer_v1_config_descriptor.ValueType)

	}

	return r, impl.ErrorPath{}
}

func NewOutputMapperFn(expressions map[string]compiled.Expression) template.OutputMapperFn {
	return func(attrs attribute.Bag) (*attribute.MutableBag, error) {
		var val interface{}
		var err error

		resultBag := attribute.GetMutableBag(nil)
		for attrName, expr := range expressions {
			if val, err = expr.Evaluate(attrs); err != nil {
				return nil, err
			}

			switch v := val.(type) {
			case net.IP:
				// conversion to []byte necessary based on current IP_ADDRESS handling within Mixer
				// TODO: remove
				log.Info("converting net.IP to []byte")
				if v4 := v.To4(); v4 != nil {
					resultBag.Set(attrName, []byte(v4))
					continue
				}
				resultBag.Set(attrName, []byte(v.To16()))
			default:
				resultBag.Set(attrName, val)
			}
		}

		return resultBag, nil
	}
}
