// Copyright 2017 Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// THIS FILE IS AUTOMATICALLY GENERATED.

package template

import (
	"context"
	"fmt"
	"net"
	"strings"

	"github.com/gogo/protobuf/proto"

	"istio.io/api/mixer/v1/config/descriptor"
	"istio.io/istio/mixer/pkg/adapter"
	"istio.io/istio/mixer/pkg/attribute"
	"istio.io/istio/mixer/pkg/il/compiled"
	"istio.io/istio/mixer/pkg/log"
	"istio.io/istio/mixer/pkg/template"
	"istio.io/istio/mixer/pkg/template/impl"

	adptTmpl "istio.io/api/mixer/v1/template"
	"istio.io/istio/mixer/pkg/config/proto"

	"istio.io/istio/mixer/adapter/svcctrl/template/svcctrlreport"

	"istio.io/istio/mixer/template/apikey"

	"istio.io/istio/mixer/template/checknothing"

	"istio.io/istio/mixer/template/listentry"

	"istio.io/istio/mixer/template/logentry"

	"istio.io/istio/mixer/template/metric"

	"istio.io/istio/mixer/template/quota"

	"istio.io/istio/mixer/template/reportnothing"

	"istio.io/istio/mixer/template/tracespan"

	"time"
)

// Add void usages for some imports so that go linter does not complain in case the imports does not get used in the
// below codegen.
var (
	_ net.IP
	_ istio_mixer_v1_config.AttributeManifest
	_ = strings.Reader{}
)

const emptyQuotes = "\"\""

type (
	getFn         func(name string) (value interface{}, found bool)
	namesFn       func() []string
	doneFn        func()
	debugStringFn func() string
	wrapperAttr   struct {
		get         getFn
		names       namesFn
		done        doneFn
		debugString debugStringFn
	}
)

func newWrapperAttrBag(get getFn, names namesFn, done doneFn, debugString debugStringFn) attribute.Bag {
	return &wrapperAttr{
		debugString: debugString,
		done:        done,
		get:         get,
		names:       names,
	}
}

// Get returns an attribute value.
func (w *wrapperAttr) Get(name string) (value interface{}, found bool) {
	return w.get(name)
}

// Names returns the names of all the attributes known to this bag.
func (w *wrapperAttr) Names() []string {
	return w.names()
}

// Done indicates the bag can be reclaimed.
func (w *wrapperAttr) Done() {
	w.done()
}

// DebugString provides a dump of an attribute Bag that avoids affecting the
// calculation of referenced attributes.
func (w *wrapperAttr) DebugString() string {
	return w.debugString()
}

var (
	SupportedTmplInfo = map[string]template.Info{

		svcctrlreport.TemplateName: {
			Name:               svcctrlreport.TemplateName,
			Impl:               "svcctrlreport",
			CtrCfg:             &svcctrlreport.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_REPORT,
			BldrInterfaceName:  svcctrlreport.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: svcctrlreport.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(svcctrlreport.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(svcctrlreport.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {

				var BuildTemplate func(param *svcctrlreport.InstanceParam,
					path string) (*svcctrlreport.Type, error)

				_ = BuildTemplate

				BuildTemplate = func(param *svcctrlreport.InstanceParam,
					path string) (*svcctrlreport.Type, error) {

					if param == nil {
						return nil, nil
					}

					infrdType := &svcctrlreport.Type{}

					var err error = nil

					if param.ApiVersion == "" || param.ApiVersion == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"ApiVersion")
					}
					if t, e := tEvalFn(param.ApiVersion); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"ApiVersion", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"ApiVersion", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.ApiOperation == "" || param.ApiOperation == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"ApiOperation")
					}
					if t, e := tEvalFn(param.ApiOperation); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"ApiOperation", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"ApiOperation", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.ApiProtocol == "" || param.ApiProtocol == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"ApiProtocol")
					}
					if t, e := tEvalFn(param.ApiProtocol); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"ApiProtocol", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"ApiProtocol", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.ApiService == "" || param.ApiService == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"ApiService")
					}
					if t, e := tEvalFn(param.ApiService); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"ApiService", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"ApiService", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.ApiKey == "" || param.ApiKey == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"ApiKey")
					}
					if t, e := tEvalFn(param.ApiKey); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"ApiKey", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"ApiKey", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.RequestTime == "" || param.RequestTime == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"RequestTime")
					}
					if t, e := tEvalFn(param.RequestTime); e != nil || t != istio_mixer_v1_config_descriptor.TIMESTAMP {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"RequestTime", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"RequestTime", t, istio_mixer_v1_config_descriptor.TIMESTAMP)
					}

					if param.RequestMethod == "" || param.RequestMethod == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"RequestMethod")
					}
					if t, e := tEvalFn(param.RequestMethod); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"RequestMethod", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"RequestMethod", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.RequestPath == "" || param.RequestPath == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"RequestPath")
					}
					if t, e := tEvalFn(param.RequestPath); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"RequestPath", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"RequestPath", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.RequestBytes == "" || param.RequestBytes == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"RequestBytes")
					}
					if t, e := tEvalFn(param.RequestBytes); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"RequestBytes", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"RequestBytes", t, istio_mixer_v1_config_descriptor.INT64)
					}

					if param.ResponseTime == "" || param.ResponseTime == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"ResponseTime")
					}
					if t, e := tEvalFn(param.ResponseTime); e != nil || t != istio_mixer_v1_config_descriptor.TIMESTAMP {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"ResponseTime", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"ResponseTime", t, istio_mixer_v1_config_descriptor.TIMESTAMP)
					}

					if param.ResponseCode == "" || param.ResponseCode == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"ResponseCode")
					}
					if t, e := tEvalFn(param.ResponseCode); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"ResponseCode", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"ResponseCode", t, istio_mixer_v1_config_descriptor.INT64)
					}

					if param.ResponseBytes == "" || param.ResponseBytes == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"ResponseBytes")
					}
					if t, e := tEvalFn(param.ResponseBytes); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"ResponseBytes", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"ResponseBytes", t, istio_mixer_v1_config_descriptor.INT64)
					}

					if param.ResponseLatency == "" || param.ResponseLatency == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"ResponseLatency")
					}
					if t, e := tEvalFn(param.ResponseLatency); e != nil || t != istio_mixer_v1_config_descriptor.DURATION {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"ResponseLatency", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"ResponseLatency", t, istio_mixer_v1_config_descriptor.DURATION)
					}

					return infrdType, err

				}

				instParam := cp.(*svcctrlreport.InstanceParam)

				return BuildTemplate(instParam, "")
			},

			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(svcctrlreport.HandlerBuilder)
				castedTypes := make(map[string]*svcctrlreport.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*svcctrlreport.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetSvcctrlReportTypes(castedTypes)
			},

			ProcessReport: func(ctx context.Context, instances []interface{}, attrs attribute.Bag, handler adapter.Handler) error {

				ins := make([]*svcctrlreport.Instance, len(instances))
				for i, instance := range instances {
					ins[i] = instance.(*svcctrlreport.Instance)
				}

				if err := handler.(svcctrlreport.Handler).HandleSvcctrlReport(ctx, ins); err != nil {
					return fmt.Errorf("failed to report all values: %v", err)
				}
				return nil

			},

			CreateInstanceBuilder: func(instanceName string, param interface{}, expb *compiled.ExpressionBuilder) template.InstanceBuilderFn {

				b, errp := newBuilder_svcctrlreport_Template(expb, param.(*svcctrlreport.InstanceParam))
				if !errp.IsNil() {
					// TODO: This preserves the current semantics of the evaluator, where compilation happens
					// in the evaluation path. Ideally this method should return an error, and we should simply
					// not create an instance builder, in the presence broken config.
					return func(_ attribute.Bag) (interface{}, error) {
						err := errp.AsCompilationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}
				}

				return func(attr attribute.Bag) (interface{}, error) {
					e, errp := b.build(attr)
					if !errp.IsNil() {
						err := errp.AsEvaluationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}

					return e, nil
				}
			},
		},

		apikey.TemplateName: {
			Name:               apikey.TemplateName,
			Impl:               "apikey",
			CtrCfg:             &apikey.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_CHECK,
			BldrInterfaceName:  apikey.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: apikey.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(apikey.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(apikey.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {

				var BuildTemplate func(param *apikey.InstanceParam,
					path string) (*apikey.Type, error)

				_ = BuildTemplate

				BuildTemplate = func(param *apikey.InstanceParam,
					path string) (*apikey.Type, error) {

					if param == nil {
						return nil, nil
					}

					infrdType := &apikey.Type{}

					var err error = nil

					if param.Api == "" || param.Api == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"Api")
					}
					if t, e := tEvalFn(param.Api); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"Api", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"Api", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.ApiVersion == "" || param.ApiVersion == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"ApiVersion")
					}
					if t, e := tEvalFn(param.ApiVersion); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"ApiVersion", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"ApiVersion", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.ApiOperation == "" || param.ApiOperation == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"ApiOperation")
					}
					if t, e := tEvalFn(param.ApiOperation); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"ApiOperation", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"ApiOperation", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.ApiKey == "" || param.ApiKey == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"ApiKey")
					}
					if t, e := tEvalFn(param.ApiKey); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"ApiKey", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"ApiKey", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.Timestamp == "" || param.Timestamp == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"Timestamp")
					}
					if t, e := tEvalFn(param.Timestamp); e != nil || t != istio_mixer_v1_config_descriptor.TIMESTAMP {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"Timestamp", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"Timestamp", t, istio_mixer_v1_config_descriptor.TIMESTAMP)
					}

					return infrdType, err

				}

				instParam := cp.(*apikey.InstanceParam)

				return BuildTemplate(instParam, "")
			},

			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(apikey.HandlerBuilder)
				castedTypes := make(map[string]*apikey.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*apikey.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetApiKeyTypes(castedTypes)
			},

			ProcessCheck: func(ctx context.Context, instName string, instance interface{}, attrs attribute.Bag,
				handler adapter.Handler) (adapter.CheckResult, error) {

				ins := instance.(*apikey.Instance)
				return handler.(apikey.Handler).HandleApiKey(ctx, ins)

			},

			CreateInstanceBuilder: func(instanceName string, param interface{}, expb *compiled.ExpressionBuilder) template.InstanceBuilderFn {

				b, errp := newBuilder_apikey_Template(expb, param.(*apikey.InstanceParam))
				if !errp.IsNil() {
					// TODO: This preserves the current semantics of the evaluator, where compilation happens
					// in the evaluation path. Ideally this method should return an error, and we should simply
					// not create an instance builder, in the presence broken config.
					return func(_ attribute.Bag) (interface{}, error) {
						err := errp.AsCompilationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}
				}

				return func(attr attribute.Bag) (interface{}, error) {
					e, errp := b.build(attr)
					if !errp.IsNil() {
						err := errp.AsEvaluationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}

					return e, nil
				}
			},
		},

		checknothing.TemplateName: {
			Name:               checknothing.TemplateName,
			Impl:               "checknothing",
			CtrCfg:             &checknothing.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_CHECK,
			BldrInterfaceName:  checknothing.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: checknothing.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(checknothing.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(checknothing.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {

				var BuildTemplate func(param *checknothing.InstanceParam,
					path string) (*checknothing.Type, error)

				_ = BuildTemplate

				BuildTemplate = func(param *checknothing.InstanceParam,
					path string) (*checknothing.Type, error) {

					if param == nil {
						return nil, nil
					}

					infrdType := &checknothing.Type{}

					var err error = nil

					return infrdType, err

				}

				instParam := cp.(*checknothing.InstanceParam)

				return BuildTemplate(instParam, "")
			},

			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(checknothing.HandlerBuilder)
				castedTypes := make(map[string]*checknothing.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*checknothing.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetCheckNothingTypes(castedTypes)
			},

			ProcessCheck: func(ctx context.Context, instName string, instance interface{}, attrs attribute.Bag,
				handler adapter.Handler) (adapter.CheckResult, error) {

				ins := instance.(*checknothing.Instance)
				return handler.(checknothing.Handler).HandleCheckNothing(ctx, ins)

			},

			CreateInstanceBuilder: func(instanceName string, param interface{}, expb *compiled.ExpressionBuilder) template.InstanceBuilderFn {

				b, errp := newBuilder_checknothing_Template(expb, param.(*checknothing.InstanceParam))
				if !errp.IsNil() {
					// TODO: This preserves the current semantics of the evaluator, where compilation happens
					// in the evaluation path. Ideally this method should return an error, and we should simply
					// not create an instance builder, in the presence broken config.
					return func(_ attribute.Bag) (interface{}, error) {
						err := errp.AsCompilationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}
				}

				return func(attr attribute.Bag) (interface{}, error) {
					e, errp := b.build(attr)
					if !errp.IsNil() {
						err := errp.AsEvaluationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}

					return e, nil
				}
			},
		},

		listentry.TemplateName: {
			Name:               listentry.TemplateName,
			Impl:               "listentry",
			CtrCfg:             &listentry.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_CHECK,
			BldrInterfaceName:  listentry.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: listentry.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(listentry.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(listentry.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {

				var BuildTemplate func(param *listentry.InstanceParam,
					path string) (*listentry.Type, error)

				_ = BuildTemplate

				BuildTemplate = func(param *listentry.InstanceParam,
					path string) (*listentry.Type, error) {

					if param == nil {
						return nil, nil
					}

					infrdType := &listentry.Type{}

					var err error = nil

					if param.Value == "" || param.Value == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"Value")
					}
					if t, e := tEvalFn(param.Value); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"Value", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"Value", t, istio_mixer_v1_config_descriptor.STRING)
					}

					return infrdType, err

				}

				instParam := cp.(*listentry.InstanceParam)

				return BuildTemplate(instParam, "")
			},

			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(listentry.HandlerBuilder)
				castedTypes := make(map[string]*listentry.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*listentry.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetListEntryTypes(castedTypes)
			},

			ProcessCheck: func(ctx context.Context, instName string, instance interface{}, attrs attribute.Bag,
				handler adapter.Handler) (adapter.CheckResult, error) {

				ins := instance.(*listentry.Instance)
				return handler.(listentry.Handler).HandleListEntry(ctx, ins)

			},

			CreateInstanceBuilder: func(instanceName string, param interface{}, expb *compiled.ExpressionBuilder) template.InstanceBuilderFn {

				b, errp := newBuilder_listentry_Template(expb, param.(*listentry.InstanceParam))
				if !errp.IsNil() {
					// TODO: This preserves the current semantics of the evaluator, where compilation happens
					// in the evaluation path. Ideally this method should return an error, and we should simply
					// not create an instance builder, in the presence broken config.
					return func(_ attribute.Bag) (interface{}, error) {
						err := errp.AsCompilationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}
				}

				return func(attr attribute.Bag) (interface{}, error) {
					e, errp := b.build(attr)
					if !errp.IsNil() {
						err := errp.AsEvaluationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}

					return e, nil
				}
			},
		},

		logentry.TemplateName: {
			Name:               logentry.TemplateName,
			Impl:               "logentry",
			CtrCfg:             &logentry.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_REPORT,
			BldrInterfaceName:  logentry.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: logentry.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(logentry.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(logentry.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {

				var BuildTemplate func(param *logentry.InstanceParam,
					path string) (*logentry.Type, error)

				_ = BuildTemplate

				BuildTemplate = func(param *logentry.InstanceParam,
					path string) (*logentry.Type, error) {

					if param == nil {
						return nil, nil
					}

					infrdType := &logentry.Type{}

					var err error = nil

					infrdType.Variables = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(param.Variables))

					for k, v := range param.Variables {

						if infrdType.Variables[k], err = tEvalFn(v); err != nil {

							return nil, fmt.Errorf("failed to evaluate expression for field '%s'; %v", path+"Variables", err)
						}
					}

					if param.Timestamp == "" || param.Timestamp == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"Timestamp")
					}
					if t, e := tEvalFn(param.Timestamp); e != nil || t != istio_mixer_v1_config_descriptor.TIMESTAMP {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"Timestamp", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"Timestamp", t, istio_mixer_v1_config_descriptor.TIMESTAMP)
					}

					if param.Severity == "" || param.Severity == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"Severity")
					}
					if t, e := tEvalFn(param.Severity); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"Severity", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"Severity", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.MonitoredResourceType == "" || param.MonitoredResourceType == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"MonitoredResourceType")
					}
					if t, e := tEvalFn(param.MonitoredResourceType); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"MonitoredResourceType", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"MonitoredResourceType", t, istio_mixer_v1_config_descriptor.STRING)
					}

					infrdType.MonitoredResourceDimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(param.MonitoredResourceDimensions))

					for k, v := range param.MonitoredResourceDimensions {

						if infrdType.MonitoredResourceDimensions[k], err = tEvalFn(v); err != nil {

							return nil, fmt.Errorf("failed to evaluate expression for field '%s'; %v", path+"MonitoredResourceDimensions", err)
						}
					}

					return infrdType, err

				}

				instParam := cp.(*logentry.InstanceParam)

				return BuildTemplate(instParam, "")
			},

			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(logentry.HandlerBuilder)
				castedTypes := make(map[string]*logentry.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*logentry.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetLogEntryTypes(castedTypes)
			},

			ProcessReport: func(ctx context.Context, instances []interface{}, attrs attribute.Bag, handler adapter.Handler) error {

				ins := make([]*logentry.Instance, len(instances))
				for i, instance := range instances {
					ins[i] = instance.(*logentry.Instance)
				}

				if err := handler.(logentry.Handler).HandleLogEntry(ctx, ins); err != nil {
					return fmt.Errorf("failed to report all values: %v", err)
				}
				return nil

			},

			CreateInstanceBuilder: func(instanceName string, param interface{}, expb *compiled.ExpressionBuilder) template.InstanceBuilderFn {

				b, errp := newBuilder_logentry_Template(expb, param.(*logentry.InstanceParam))
				if !errp.IsNil() {
					// TODO: This preserves the current semantics of the evaluator, where compilation happens
					// in the evaluation path. Ideally this method should return an error, and we should simply
					// not create an instance builder, in the presence broken config.
					return func(_ attribute.Bag) (interface{}, error) {
						err := errp.AsCompilationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}
				}

				return func(attr attribute.Bag) (interface{}, error) {
					e, errp := b.build(attr)
					if !errp.IsNil() {
						err := errp.AsEvaluationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}

					return e, nil
				}
			},
		},

		metric.TemplateName: {
			Name:               metric.TemplateName,
			Impl:               "metric",
			CtrCfg:             &metric.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_REPORT,
			BldrInterfaceName:  metric.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: metric.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(metric.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(metric.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {

				var BuildTemplate func(param *metric.InstanceParam,
					path string) (*metric.Type, error)

				_ = BuildTemplate

				BuildTemplate = func(param *metric.InstanceParam,
					path string) (*metric.Type, error) {

					if param == nil {
						return nil, nil
					}

					infrdType := &metric.Type{}

					var err error = nil

					if param.Value == "" || param.Value == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"Value")
					}
					if infrdType.Value, err = tEvalFn(param.Value); err != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field '%s'; %v", path+"Value", err)
					}

					infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(param.Dimensions))

					for k, v := range param.Dimensions {

						if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {

							return nil, fmt.Errorf("failed to evaluate expression for field '%s'; %v", path+"Dimensions", err)
						}
					}

					if param.MonitoredResourceType == "" || param.MonitoredResourceType == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"MonitoredResourceType")
					}
					if t, e := tEvalFn(param.MonitoredResourceType); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"MonitoredResourceType", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"MonitoredResourceType", t, istio_mixer_v1_config_descriptor.STRING)
					}

					infrdType.MonitoredResourceDimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(param.MonitoredResourceDimensions))

					for k, v := range param.MonitoredResourceDimensions {

						if infrdType.MonitoredResourceDimensions[k], err = tEvalFn(v); err != nil {

							return nil, fmt.Errorf("failed to evaluate expression for field '%s'; %v", path+"MonitoredResourceDimensions", err)
						}
					}

					return infrdType, err

				}

				instParam := cp.(*metric.InstanceParam)

				return BuildTemplate(instParam, "")
			},

			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(metric.HandlerBuilder)
				castedTypes := make(map[string]*metric.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*metric.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetMetricTypes(castedTypes)
			},

			ProcessReport: func(ctx context.Context, instances []interface{}, attrs attribute.Bag, handler adapter.Handler) error {

				ins := make([]*metric.Instance, len(instances))
				for i, instance := range instances {
					ins[i] = instance.(*metric.Instance)
				}

				if err := handler.(metric.Handler).HandleMetric(ctx, ins); err != nil {
					return fmt.Errorf("failed to report all values: %v", err)
				}
				return nil

			},

			CreateInstanceBuilder: func(instanceName string, param interface{}, expb *compiled.ExpressionBuilder) template.InstanceBuilderFn {

				b, errp := newBuilder_metric_Template(expb, param.(*metric.InstanceParam))
				if !errp.IsNil() {
					// TODO: This preserves the current semantics of the evaluator, where compilation happens
					// in the evaluation path. Ideally this method should return an error, and we should simply
					// not create an instance builder, in the presence broken config.
					return func(_ attribute.Bag) (interface{}, error) {
						err := errp.AsCompilationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}
				}

				return func(attr attribute.Bag) (interface{}, error) {
					e, errp := b.build(attr)
					if !errp.IsNil() {
						err := errp.AsEvaluationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}

					return e, nil
				}
			},
		},

		quota.TemplateName: {
			Name:               quota.TemplateName,
			Impl:               "quota",
			CtrCfg:             &quota.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_QUOTA,
			BldrInterfaceName:  quota.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: quota.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(quota.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(quota.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {

				var BuildTemplate func(param *quota.InstanceParam,
					path string) (*quota.Type, error)

				_ = BuildTemplate

				BuildTemplate = func(param *quota.InstanceParam,
					path string) (*quota.Type, error) {

					if param == nil {
						return nil, nil
					}

					infrdType := &quota.Type{}

					var err error = nil

					infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(param.Dimensions))

					for k, v := range param.Dimensions {

						if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {

							return nil, fmt.Errorf("failed to evaluate expression for field '%s'; %v", path+"Dimensions", err)
						}
					}

					return infrdType, err

				}

				instParam := cp.(*quota.InstanceParam)

				return BuildTemplate(instParam, "")
			},

			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(quota.HandlerBuilder)
				castedTypes := make(map[string]*quota.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*quota.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetQuotaTypes(castedTypes)
			},

			ProcessQuota: func(ctx context.Context, instName string, instance interface{}, attrs attribute.Bag,
				handler adapter.Handler, args adapter.QuotaArgs) (adapter.QuotaResult, error) {

				ins := instance.(*quota.Instance)
				return handler.(quota.Handler).HandleQuota(ctx, ins, args)

			},

			CreateInstanceBuilder: func(instanceName string, param interface{}, expb *compiled.ExpressionBuilder) template.InstanceBuilderFn {

				b, errp := newBuilder_quota_Template(expb, param.(*quota.InstanceParam))
				if !errp.IsNil() {
					// TODO: This preserves the current semantics of the evaluator, where compilation happens
					// in the evaluation path. Ideally this method should return an error, and we should simply
					// not create an instance builder, in the presence broken config.
					return func(_ attribute.Bag) (interface{}, error) {
						err := errp.AsCompilationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}
				}

				return func(attr attribute.Bag) (interface{}, error) {
					e, errp := b.build(attr)
					if !errp.IsNil() {
						err := errp.AsEvaluationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}

					return e, nil
				}
			},
		},

		reportnothing.TemplateName: {
			Name:               reportnothing.TemplateName,
			Impl:               "reportnothing",
			CtrCfg:             &reportnothing.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_REPORT,
			BldrInterfaceName:  reportnothing.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: reportnothing.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(reportnothing.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(reportnothing.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {

				var BuildTemplate func(param *reportnothing.InstanceParam,
					path string) (*reportnothing.Type, error)

				_ = BuildTemplate

				BuildTemplate = func(param *reportnothing.InstanceParam,
					path string) (*reportnothing.Type, error) {

					if param == nil {
						return nil, nil
					}

					infrdType := &reportnothing.Type{}

					var err error = nil

					return infrdType, err

				}

				instParam := cp.(*reportnothing.InstanceParam)

				return BuildTemplate(instParam, "")
			},

			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(reportnothing.HandlerBuilder)
				castedTypes := make(map[string]*reportnothing.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*reportnothing.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetReportNothingTypes(castedTypes)
			},

			ProcessReport: func(ctx context.Context, instances []interface{}, attrs attribute.Bag, handler adapter.Handler) error {

				ins := make([]*reportnothing.Instance, len(instances))
				for i, instance := range instances {
					ins[i] = instance.(*reportnothing.Instance)
				}

				if err := handler.(reportnothing.Handler).HandleReportNothing(ctx, ins); err != nil {
					return fmt.Errorf("failed to report all values: %v", err)
				}
				return nil

			},

			CreateInstanceBuilder: func(instanceName string, param interface{}, expb *compiled.ExpressionBuilder) template.InstanceBuilderFn {

				b, errp := newBuilder_reportnothing_Template(expb, param.(*reportnothing.InstanceParam))
				if !errp.IsNil() {
					// TODO: This preserves the current semantics of the evaluator, where compilation happens
					// in the evaluation path. Ideally this method should return an error, and we should simply
					// not create an instance builder, in the presence broken config.
					return func(_ attribute.Bag) (interface{}, error) {
						err := errp.AsCompilationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}
				}

				return func(attr attribute.Bag) (interface{}, error) {
					e, errp := b.build(attr)
					if !errp.IsNil() {
						err := errp.AsEvaluationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}

					return e, nil
				}
			},
		},

		tracespan.TemplateName: {
			Name:               tracespan.TemplateName,
			Impl:               "tracespan",
			CtrCfg:             &tracespan.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_REPORT,
			BldrInterfaceName:  tracespan.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: tracespan.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(tracespan.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(tracespan.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {

				var BuildTemplate func(param *tracespan.InstanceParam,
					path string) (*tracespan.Type, error)

				_ = BuildTemplate

				BuildTemplate = func(param *tracespan.InstanceParam,
					path string) (*tracespan.Type, error) {

					if param == nil {
						return nil, nil
					}

					infrdType := &tracespan.Type{}

					var err error = nil

					if param.TraceId == "" || param.TraceId == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"TraceId")
					}
					if t, e := tEvalFn(param.TraceId); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"TraceId", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"TraceId", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.SpanId == "" || param.SpanId == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"SpanId")
					}
					if t, e := tEvalFn(param.SpanId); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"SpanId", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"SpanId", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.ParentSpanId == "" || param.ParentSpanId == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"ParentSpanId")
					}
					if t, e := tEvalFn(param.ParentSpanId); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"ParentSpanId", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"ParentSpanId", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.SpanName == "" || param.SpanName == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"SpanName")
					}
					if t, e := tEvalFn(param.SpanName); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"SpanName", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"SpanName", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if param.StartTime == "" || param.StartTime == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"StartTime")
					}
					if t, e := tEvalFn(param.StartTime); e != nil || t != istio_mixer_v1_config_descriptor.TIMESTAMP {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"StartTime", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"StartTime", t, istio_mixer_v1_config_descriptor.TIMESTAMP)
					}

					if param.EndTime == "" || param.EndTime == emptyQuotes {
						return nil, fmt.Errorf("expression for field '%s' cannot be empty", path+"EndTime")
					}
					if t, e := tEvalFn(param.EndTime); e != nil || t != istio_mixer_v1_config_descriptor.TIMESTAMP {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field '%s': %v", path+"EndTime", e)
						}
						return nil, fmt.Errorf("error type checking for field '%s': Evaluated expression type %v want %v", path+"EndTime", t, istio_mixer_v1_config_descriptor.TIMESTAMP)
					}

					infrdType.SpanTags = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(param.SpanTags))

					for k, v := range param.SpanTags {

						if infrdType.SpanTags[k], err = tEvalFn(v); err != nil {

							return nil, fmt.Errorf("failed to evaluate expression for field '%s'; %v", path+"SpanTags", err)
						}
					}

					return infrdType, err

				}

				instParam := cp.(*tracespan.InstanceParam)

				return BuildTemplate(instParam, "")
			},

			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(tracespan.HandlerBuilder)
				castedTypes := make(map[string]*tracespan.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*tracespan.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetTraceSpanTypes(castedTypes)
			},

			ProcessReport: func(ctx context.Context, instances []interface{}, attrs attribute.Bag, handler adapter.Handler) error {

				ins := make([]*tracespan.Instance, len(instances))
				for i, instance := range instances {
					ins[i] = instance.(*tracespan.Instance)
				}

				if err := handler.(tracespan.Handler).HandleTraceSpan(ctx, ins); err != nil {
					return fmt.Errorf("failed to report all values: %v", err)
				}
				return nil

			},

			CreateInstanceBuilder: func(instanceName string, param interface{}, expb *compiled.ExpressionBuilder) template.InstanceBuilderFn {

				b, errp := newBuilder_tracespan_Template(expb, param.(*tracespan.InstanceParam))
				if !errp.IsNil() {
					// TODO: This preserves the current semantics of the evaluator, where compilation happens
					// in the evaluation path. Ideally this method should return an error, and we should simply
					// not create an instance builder, in the presence broken config.
					return func(_ attribute.Bag) (interface{}, error) {
						err := errp.AsCompilationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}
				}

				return func(attr attribute.Bag) (interface{}, error) {
					e, errp := b.build(attr)
					if !errp.IsNil() {
						err := errp.AsEvaluationError(instanceName)
						log.Error(err.Error())
						return err, nil
					}

					return e, nil
				}
			},
		},
	}
)

// builder_svcctrlreport_Template builds an instance of Template.
type builder_svcctrlreport_Template struct {
	bldApiVersion compiled.Expression

	bldApiOperation compiled.Expression

	bldApiProtocol compiled.Expression

	bldApiService compiled.Expression

	bldApiKey compiled.Expression

	bldRequestTime compiled.Expression

	bldRequestMethod compiled.Expression

	bldRequestPath compiled.Expression

	bldRequestBytes compiled.Expression

	bldResponseTime compiled.Expression

	bldResponseCode compiled.Expression

	bldResponseBytes compiled.Expression

	bldResponseLatency compiled.Expression
} // builder_svcctrlreport_Template

func newBuilder_svcctrlreport_Template(
	expb *compiled.ExpressionBuilder, param *svcctrlreport.InstanceParam) (*builder_svcctrlreport_Template, impl.ErrorPath) {

	if param == nil {
		return nil, impl.ErrorPath{}
	}

	b := &builder_svcctrlreport_Template{}

	var exp compiled.Expression
	_ = exp
	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp

	b.bldApiVersion, err = expb.Compile(param.ApiVersion)
	if err != nil {
		return nil, impl.NewErrorPath("ApiVersion", err)
	}

	b.bldApiOperation, err = expb.Compile(param.ApiOperation)
	if err != nil {
		return nil, impl.NewErrorPath("ApiOperation", err)
	}

	b.bldApiProtocol, err = expb.Compile(param.ApiProtocol)
	if err != nil {
		return nil, impl.NewErrorPath("ApiProtocol", err)
	}

	b.bldApiService, err = expb.Compile(param.ApiService)
	if err != nil {
		return nil, impl.NewErrorPath("ApiService", err)
	}

	b.bldApiKey, err = expb.Compile(param.ApiKey)
	if err != nil {
		return nil, impl.NewErrorPath("ApiKey", err)
	}

	b.bldRequestTime, err = expb.Compile(param.RequestTime)
	if err != nil {
		return nil, impl.NewErrorPath("RequestTime", err)
	}

	b.bldRequestMethod, err = expb.Compile(param.RequestMethod)
	if err != nil {
		return nil, impl.NewErrorPath("RequestMethod", err)
	}

	b.bldRequestPath, err = expb.Compile(param.RequestPath)
	if err != nil {
		return nil, impl.NewErrorPath("RequestPath", err)
	}

	b.bldRequestBytes, err = expb.Compile(param.RequestBytes)
	if err != nil {
		return nil, impl.NewErrorPath("RequestBytes", err)
	}

	b.bldResponseTime, err = expb.Compile(param.ResponseTime)
	if err != nil {
		return nil, impl.NewErrorPath("ResponseTime", err)
	}

	b.bldResponseCode, err = expb.Compile(param.ResponseCode)
	if err != nil {
		return nil, impl.NewErrorPath("ResponseCode", err)
	}

	b.bldResponseBytes, err = expb.Compile(param.ResponseBytes)
	if err != nil {
		return nil, impl.NewErrorPath("ResponseBytes", err)
	}

	b.bldResponseLatency, err = expb.Compile(param.ResponseLatency)
	if err != nil {
		return nil, impl.NewErrorPath("ResponseLatency", err)
	}

	return b, impl.ErrorPath{}
}

func (b *builder_svcctrlreport_Template) build(
	attrs attribute.Bag) (*svcctrlreport.Instance, impl.ErrorPath) {

	if b == nil {
		return nil, impl.ErrorPath{}
	}

	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp
	var iface interface{}
	_ = iface

	r := &svcctrlreport.Instance{}

	if iface, err = b.bldApiVersion.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("ApiVersion", err)
	}
	r.ApiVersion = iface.(string)

	if iface, err = b.bldApiOperation.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("ApiOperation", err)
	}
	r.ApiOperation = iface.(string)

	if iface, err = b.bldApiProtocol.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("ApiProtocol", err)
	}
	r.ApiProtocol = iface.(string)

	if iface, err = b.bldApiService.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("ApiService", err)
	}
	r.ApiService = iface.(string)

	if iface, err = b.bldApiKey.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("ApiKey", err)
	}
	r.ApiKey = iface.(string)

	if iface, err = b.bldRequestTime.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("RequestTime", err)
	}
	r.RequestTime = iface.(time.Time)

	if iface, err = b.bldRequestMethod.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("RequestMethod", err)
	}
	r.RequestMethod = iface.(string)

	if iface, err = b.bldRequestPath.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("RequestPath", err)
	}
	r.RequestPath = iface.(string)

	if iface, err = b.bldRequestBytes.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("RequestBytes", err)
	}
	r.RequestBytes = iface.(int64)

	if iface, err = b.bldResponseTime.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("ResponseTime", err)
	}
	r.ResponseTime = iface.(time.Time)

	if iface, err = b.bldResponseCode.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("ResponseCode", err)
	}
	r.ResponseCode = iface.(int64)

	if iface, err = b.bldResponseBytes.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("ResponseBytes", err)
	}
	r.ResponseBytes = iface.(int64)

	if iface, err = b.bldResponseLatency.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("ResponseLatency", err)
	}
	r.ResponseLatency = iface.(time.Duration)

	return r, impl.ErrorPath{}
}

// builder_apikey_Template builds an instance of Template.
type builder_apikey_Template struct {
	bldApi compiled.Expression

	bldApiVersion compiled.Expression

	bldApiOperation compiled.Expression

	bldApiKey compiled.Expression

	bldTimestamp compiled.Expression
} // builder_apikey_Template

func newBuilder_apikey_Template(
	expb *compiled.ExpressionBuilder, param *apikey.InstanceParam) (*builder_apikey_Template, impl.ErrorPath) {

	if param == nil {
		return nil, impl.ErrorPath{}
	}

	b := &builder_apikey_Template{}

	var exp compiled.Expression
	_ = exp
	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp

	b.bldApi, err = expb.Compile(param.Api)
	if err != nil {
		return nil, impl.NewErrorPath("Api", err)
	}

	b.bldApiVersion, err = expb.Compile(param.ApiVersion)
	if err != nil {
		return nil, impl.NewErrorPath("ApiVersion", err)
	}

	b.bldApiOperation, err = expb.Compile(param.ApiOperation)
	if err != nil {
		return nil, impl.NewErrorPath("ApiOperation", err)
	}

	b.bldApiKey, err = expb.Compile(param.ApiKey)
	if err != nil {
		return nil, impl.NewErrorPath("ApiKey", err)
	}

	b.bldTimestamp, err = expb.Compile(param.Timestamp)
	if err != nil {
		return nil, impl.NewErrorPath("Timestamp", err)
	}

	return b, impl.ErrorPath{}
}

func (b *builder_apikey_Template) build(
	attrs attribute.Bag) (*apikey.Instance, impl.ErrorPath) {

	if b == nil {
		return nil, impl.ErrorPath{}
	}

	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp
	var iface interface{}
	_ = iface

	r := &apikey.Instance{}

	if iface, err = b.bldApi.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("Api", err)
	}
	r.Api = iface.(string)

	if iface, err = b.bldApiVersion.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("ApiVersion", err)
	}
	r.ApiVersion = iface.(string)

	if iface, err = b.bldApiOperation.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("ApiOperation", err)
	}
	r.ApiOperation = iface.(string)

	if iface, err = b.bldApiKey.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("ApiKey", err)
	}
	r.ApiKey = iface.(string)

	if iface, err = b.bldTimestamp.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("Timestamp", err)
	}
	r.Timestamp = iface.(time.Time)

	return r, impl.ErrorPath{}
}

// builder_checknothing_Template builds an instance of Template.
type builder_checknothing_Template struct {
} // builder_checknothing_Template

func newBuilder_checknothing_Template(
	expb *compiled.ExpressionBuilder, param *checknothing.InstanceParam) (*builder_checknothing_Template, impl.ErrorPath) {

	if param == nil {
		return nil, impl.ErrorPath{}
	}

	b := &builder_checknothing_Template{}

	var exp compiled.Expression
	_ = exp
	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp

	return b, impl.ErrorPath{}
}

func (b *builder_checknothing_Template) build(
	attrs attribute.Bag) (*checknothing.Instance, impl.ErrorPath) {

	if b == nil {
		return nil, impl.ErrorPath{}
	}

	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp
	var iface interface{}
	_ = iface

	r := &checknothing.Instance{}

	return r, impl.ErrorPath{}
}

// builder_listentry_Template builds an instance of Template.
type builder_listentry_Template struct {
	bldValue compiled.Expression
} // builder_listentry_Template

func newBuilder_listentry_Template(
	expb *compiled.ExpressionBuilder, param *listentry.InstanceParam) (*builder_listentry_Template, impl.ErrorPath) {

	if param == nil {
		return nil, impl.ErrorPath{}
	}

	b := &builder_listentry_Template{}

	var exp compiled.Expression
	_ = exp
	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp

	b.bldValue, err = expb.Compile(param.Value)
	if err != nil {
		return nil, impl.NewErrorPath("Value", err)
	}

	return b, impl.ErrorPath{}
}

func (b *builder_listentry_Template) build(
	attrs attribute.Bag) (*listentry.Instance, impl.ErrorPath) {

	if b == nil {
		return nil, impl.ErrorPath{}
	}

	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp
	var iface interface{}
	_ = iface

	r := &listentry.Instance{}

	if iface, err = b.bldValue.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("Value", err)
	}
	r.Value = iface.(string)

	return r, impl.ErrorPath{}
}

// builder_logentry_Template builds an instance of Template.
type builder_logentry_Template struct {
	bldVariables map[string]compiled.Expression

	bldTimestamp compiled.Expression

	bldSeverity compiled.Expression

	bldMonitoredResourceType compiled.Expression

	bldMonitoredResourceDimensions map[string]compiled.Expression
} // builder_logentry_Template

func newBuilder_logentry_Template(
	expb *compiled.ExpressionBuilder, param *logentry.InstanceParam) (*builder_logentry_Template, impl.ErrorPath) {

	if param == nil {
		return nil, impl.ErrorPath{}
	}

	b := &builder_logentry_Template{}

	var exp compiled.Expression
	_ = exp
	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp

	b.bldVariables = make(map[string]compiled.Expression, len(param.Variables))
	for k, v := range param.Variables {
		var exp compiled.Expression
		if exp, err = expb.Compile(v); err != nil {
			return nil, impl.NewErrorPath("Variables["+k+"].", err)
		}
		b.bldVariables[k] = exp
	}

	b.bldTimestamp, err = expb.Compile(param.Timestamp)
	if err != nil {
		return nil, impl.NewErrorPath("Timestamp", err)
	}

	b.bldSeverity, err = expb.Compile(param.Severity)
	if err != nil {
		return nil, impl.NewErrorPath("Severity", err)
	}

	b.bldMonitoredResourceType, err = expb.Compile(param.MonitoredResourceType)
	if err != nil {
		return nil, impl.NewErrorPath("MonitoredResourceType", err)
	}

	b.bldMonitoredResourceDimensions = make(map[string]compiled.Expression, len(param.MonitoredResourceDimensions))
	for k, v := range param.MonitoredResourceDimensions {
		var exp compiled.Expression
		if exp, err = expb.Compile(v); err != nil {
			return nil, impl.NewErrorPath("MonitoredResourceDimensions["+k+"].", err)
		}
		b.bldMonitoredResourceDimensions[k] = exp
	}

	return b, impl.ErrorPath{}
}

func (b *builder_logentry_Template) build(
	attrs attribute.Bag) (*logentry.Instance, impl.ErrorPath) {

	if b == nil {
		return nil, impl.ErrorPath{}
	}

	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp
	var iface interface{}
	_ = iface

	r := &logentry.Instance{}

	r.Variables = make(map[string]interface{}, len(b.bldVariables))

	for k, v := range b.bldVariables {
		if iface, err = v.Evaluate(attrs); err != nil {
			return nil, impl.NewErrorPath("Variables["+k+"].", err)
		}

		r.Variables[k] = iface.(istio_mixer_v1_config_descriptor.ValueType)

	}

	if iface, err = b.bldTimestamp.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("Timestamp", err)
	}
	r.Timestamp = iface.(time.Time)

	if iface, err = b.bldSeverity.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("Severity", err)
	}
	r.Severity = iface.(string)

	if iface, err = b.bldMonitoredResourceType.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("MonitoredResourceType", err)
	}
	r.MonitoredResourceType = iface.(string)

	r.MonitoredResourceDimensions = make(map[string]interface{}, len(b.bldMonitoredResourceDimensions))

	for k, v := range b.bldMonitoredResourceDimensions {
		if iface, err = v.Evaluate(attrs); err != nil {
			return nil, impl.NewErrorPath("MonitoredResourceDimensions["+k+"].", err)
		}

		r.MonitoredResourceDimensions[k] = iface.(istio_mixer_v1_config_descriptor.ValueType)

	}

	return r, impl.ErrorPath{}
}

// builder_metric_Template builds an instance of Template.
type builder_metric_Template struct {
	bldValue compiled.Expression

	bldDimensions map[string]compiled.Expression

	bldMonitoredResourceType compiled.Expression

	bldMonitoredResourceDimensions map[string]compiled.Expression
} // builder_metric_Template

func newBuilder_metric_Template(
	expb *compiled.ExpressionBuilder, param *metric.InstanceParam) (*builder_metric_Template, impl.ErrorPath) {

	if param == nil {
		return nil, impl.ErrorPath{}
	}

	b := &builder_metric_Template{}

	var exp compiled.Expression
	_ = exp
	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp

	b.bldValue, err = expb.Compile(param.Value)
	if err != nil {
		return nil, impl.NewErrorPath("Value", err)
	}

	b.bldDimensions = make(map[string]compiled.Expression, len(param.Dimensions))
	for k, v := range param.Dimensions {
		var exp compiled.Expression
		if exp, err = expb.Compile(v); err != nil {
			return nil, impl.NewErrorPath("Dimensions["+k+"].", err)
		}
		b.bldDimensions[k] = exp
	}

	b.bldMonitoredResourceType, err = expb.Compile(param.MonitoredResourceType)
	if err != nil {
		return nil, impl.NewErrorPath("MonitoredResourceType", err)
	}

	b.bldMonitoredResourceDimensions = make(map[string]compiled.Expression, len(param.MonitoredResourceDimensions))
	for k, v := range param.MonitoredResourceDimensions {
		var exp compiled.Expression
		if exp, err = expb.Compile(v); err != nil {
			return nil, impl.NewErrorPath("MonitoredResourceDimensions["+k+"].", err)
		}
		b.bldMonitoredResourceDimensions[k] = exp
	}

	return b, impl.ErrorPath{}
}

func (b *builder_metric_Template) build(
	attrs attribute.Bag) (*metric.Instance, impl.ErrorPath) {

	if b == nil {
		return nil, impl.ErrorPath{}
	}

	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp
	var iface interface{}
	_ = iface

	r := &metric.Instance{}

	if iface, err = b.bldValue.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("Value", err)
	}
	r.Value = iface.(istio_mixer_v1_config_descriptor.ValueType)

	r.Dimensions = make(map[string]interface{}, len(b.bldDimensions))

	for k, v := range b.bldDimensions {
		if iface, err = v.Evaluate(attrs); err != nil {
			return nil, impl.NewErrorPath("Dimensions["+k+"].", err)
		}

		r.Dimensions[k] = iface.(istio_mixer_v1_config_descriptor.ValueType)

	}

	if iface, err = b.bldMonitoredResourceType.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("MonitoredResourceType", err)
	}
	r.MonitoredResourceType = iface.(string)

	r.MonitoredResourceDimensions = make(map[string]interface{}, len(b.bldMonitoredResourceDimensions))

	for k, v := range b.bldMonitoredResourceDimensions {
		if iface, err = v.Evaluate(attrs); err != nil {
			return nil, impl.NewErrorPath("MonitoredResourceDimensions["+k+"].", err)
		}

		r.MonitoredResourceDimensions[k] = iface.(istio_mixer_v1_config_descriptor.ValueType)

	}

	return r, impl.ErrorPath{}
}

// builder_quota_Template builds an instance of Template.
type builder_quota_Template struct {
	bldDimensions map[string]compiled.Expression
} // builder_quota_Template

func newBuilder_quota_Template(
	expb *compiled.ExpressionBuilder, param *quota.InstanceParam) (*builder_quota_Template, impl.ErrorPath) {

	if param == nil {
		return nil, impl.ErrorPath{}
	}

	b := &builder_quota_Template{}

	var exp compiled.Expression
	_ = exp
	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp

	b.bldDimensions = make(map[string]compiled.Expression, len(param.Dimensions))
	for k, v := range param.Dimensions {
		var exp compiled.Expression
		if exp, err = expb.Compile(v); err != nil {
			return nil, impl.NewErrorPath("Dimensions["+k+"].", err)
		}
		b.bldDimensions[k] = exp
	}

	return b, impl.ErrorPath{}
}

func (b *builder_quota_Template) build(
	attrs attribute.Bag) (*quota.Instance, impl.ErrorPath) {

	if b == nil {
		return nil, impl.ErrorPath{}
	}

	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp
	var iface interface{}
	_ = iface

	r := &quota.Instance{}

	r.Dimensions = make(map[string]interface{}, len(b.bldDimensions))

	for k, v := range b.bldDimensions {
		if iface, err = v.Evaluate(attrs); err != nil {
			return nil, impl.NewErrorPath("Dimensions["+k+"].", err)
		}

		r.Dimensions[k] = iface.(istio_mixer_v1_config_descriptor.ValueType)

	}

	return r, impl.ErrorPath{}
}

// builder_reportnothing_Template builds an instance of Template.
type builder_reportnothing_Template struct {
} // builder_reportnothing_Template

func newBuilder_reportnothing_Template(
	expb *compiled.ExpressionBuilder, param *reportnothing.InstanceParam) (*builder_reportnothing_Template, impl.ErrorPath) {

	if param == nil {
		return nil, impl.ErrorPath{}
	}

	b := &builder_reportnothing_Template{}

	var exp compiled.Expression
	_ = exp
	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp

	return b, impl.ErrorPath{}
}

func (b *builder_reportnothing_Template) build(
	attrs attribute.Bag) (*reportnothing.Instance, impl.ErrorPath) {

	if b == nil {
		return nil, impl.ErrorPath{}
	}

	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp
	var iface interface{}
	_ = iface

	r := &reportnothing.Instance{}

	return r, impl.ErrorPath{}
}

// builder_tracespan_Template builds an instance of Template.
type builder_tracespan_Template struct {
	bldTraceId compiled.Expression

	bldSpanId compiled.Expression

	bldParentSpanId compiled.Expression

	bldSpanName compiled.Expression

	bldStartTime compiled.Expression

	bldEndTime compiled.Expression

	bldSpanTags map[string]compiled.Expression
} // builder_tracespan_Template

func newBuilder_tracespan_Template(
	expb *compiled.ExpressionBuilder, param *tracespan.InstanceParam) (*builder_tracespan_Template, impl.ErrorPath) {

	if param == nil {
		return nil, impl.ErrorPath{}
	}

	b := &builder_tracespan_Template{}

	var exp compiled.Expression
	_ = exp
	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp

	b.bldTraceId, err = expb.Compile(param.TraceId)
	if err != nil {
		return nil, impl.NewErrorPath("TraceId", err)
	}

	b.bldSpanId, err = expb.Compile(param.SpanId)
	if err != nil {
		return nil, impl.NewErrorPath("SpanId", err)
	}

	b.bldParentSpanId, err = expb.Compile(param.ParentSpanId)
	if err != nil {
		return nil, impl.NewErrorPath("ParentSpanId", err)
	}

	b.bldSpanName, err = expb.Compile(param.SpanName)
	if err != nil {
		return nil, impl.NewErrorPath("SpanName", err)
	}

	b.bldStartTime, err = expb.Compile(param.StartTime)
	if err != nil {
		return nil, impl.NewErrorPath("StartTime", err)
	}

	b.bldEndTime, err = expb.Compile(param.EndTime)
	if err != nil {
		return nil, impl.NewErrorPath("EndTime", err)
	}

	b.bldSpanTags = make(map[string]compiled.Expression, len(param.SpanTags))
	for k, v := range param.SpanTags {
		var exp compiled.Expression
		if exp, err = expb.Compile(v); err != nil {
			return nil, impl.NewErrorPath("SpanTags["+k+"].", err)
		}
		b.bldSpanTags[k] = exp
	}

	return b, impl.ErrorPath{}
}

func (b *builder_tracespan_Template) build(
	attrs attribute.Bag) (*tracespan.Instance, impl.ErrorPath) {

	if b == nil {
		return nil, impl.ErrorPath{}
	}

	var err error
	_ = err
	var errp impl.ErrorPath
	_ = errp
	var iface interface{}
	_ = iface

	r := &tracespan.Instance{}

	if iface, err = b.bldTraceId.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("TraceId", err)
	}
	r.TraceId = iface.(string)

	if iface, err = b.bldSpanId.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("SpanId", err)
	}
	r.SpanId = iface.(string)

	if iface, err = b.bldParentSpanId.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("ParentSpanId", err)
	}
	r.ParentSpanId = iface.(string)

	if iface, err = b.bldSpanName.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("SpanName", err)
	}
	r.SpanName = iface.(string)

	if iface, err = b.bldStartTime.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("StartTime", err)
	}
	r.StartTime = iface.(time.Time)

	if iface, err = b.bldEndTime.Evaluate(attrs); err != nil {
		return nil, impl.NewErrorPath("EndTime", err)
	}
	r.EndTime = iface.(time.Time)

	r.SpanTags = make(map[string]interface{}, len(b.bldSpanTags))

	for k, v := range b.bldSpanTags {
		if iface, err = v.Evaluate(attrs); err != nil {
			return nil, impl.NewErrorPath("SpanTags["+k+"].", err)
		}

		r.SpanTags[k] = iface.(istio_mixer_v1_config_descriptor.ValueType)

	}

	return r, impl.ErrorPath{}
}

func NewOutputMapperFn(expressions map[string]compiled.Expression) template.OutputMapperFn {
	return func(attrs attribute.Bag) (*attribute.MutableBag, error) {
		var val interface{}
		var err error

		resultBag := attribute.GetMutableBag(nil)
		for attrName, expr := range expressions {
			if val, err = expr.Evaluate(attrs); err != nil {
				return nil, err
			}

			switch v := val.(type) {
			case net.IP:
				// conversion to []byte necessary based on current IP_ADDRESS handling within Mixer
				// TODO: remove
				log.Info("converting net.IP to []byte")
				if v4 := v.To4(); v4 != nil {
					resultBag.Set(attrName, []byte(v4))
					continue
				}
				resultBag.Set(attrName, []byte(v.To16()))
			default:
				resultBag.Set(attrName, val)
			}
		}

		return resultBag, nil
	}
}
