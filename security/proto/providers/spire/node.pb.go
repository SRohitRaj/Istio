// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: security/proto/providers/spire/node.proto

// The Node API is exposed by the Spire Server to Node Agents.  A node
// agent uses this API to attest the node it is running on, to retrieve the
// list of identities that are allowed to run on that node, and to retrieve
// SVIDs by presenting certificate signing requests to the Spire Server.

package node

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// A type which contains the "Spiffe Verifiable Identity Document" and
// a TTL indicating when the SVID expires.
type X509SVID struct {
	// X509 SVID and intermediates necessary to form a chain of trust back
	// to a root CA in the bundle.
	CertChain []byte `protobuf:"bytes,3,opt,name=cert_chain,json=certChain,proto3" json:"cert_chain,omitempty"`
	// SVID expiration timestamp (in seconds since Unix epoch)
	ExpiresAt int64 `protobuf:"varint,2,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
}

func (m *X509SVID) Reset()      { *m = X509SVID{} }
func (*X509SVID) ProtoMessage() {}
func (*X509SVID) Descriptor() ([]byte, []int) {
	return fileDescriptor_612fe91d1919e776, []int{0}
}
func (m *X509SVID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *X509SVID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_X509SVID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *X509SVID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_X509SVID.Merge(m, src)
}
func (m *X509SVID) XXX_Size() int {
	return m.Size()
}
func (m *X509SVID) XXX_DiscardUnknown() {
	xxx_messageInfo_X509SVID.DiscardUnknown(m)
}

var xxx_messageInfo_X509SVID proto.InternalMessageInfo

func (m *X509SVID) GetCertChain() []byte {
	if m != nil {
		return m.CertChain
	}
	return nil
}

func (m *X509SVID) GetExpiresAt() int64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

// A message returned by the Spire Server, which includes a map of signed SVIDs and
//a list of all current Registration Entries which are relevant to the caller SPIFFE ID.
type X509SVIDUpdate struct {
	// A map containing SVID values and corresponding SPIFFE IDs as the
	// keys. Map[SPIFFE_ID] => SVID.
	Svids map[string]*X509SVID `protobuf:"bytes,1,rep,name=svids,proto3" json:"svids,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// A type representing a curated record that the Spire Server uses to set up
	// and manage the various registered nodes and workloads that are controlled by it.
	RegistrationEntries []*RegistrationEntry `protobuf:"bytes,3,rep,name=registration_entries,json=registrationEntries,proto3" json:"registration_entries,omitempty"`
	// Trust bundles associated with the SVIDs, keyed by trust domain SPIFFE
	// ID. Bundles included are the trust bundle for the server trust domain
	// and any federated trust domain bundles applicable to the SVIDs.
	Bundles map[string]*Bundle `protobuf:"bytes,5,rep,name=bundles,proto3" json:"bundles,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *X509SVIDUpdate) Reset()      { *m = X509SVIDUpdate{} }
func (*X509SVIDUpdate) ProtoMessage() {}
func (*X509SVIDUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_612fe91d1919e776, []int{1}
}
func (m *X509SVIDUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *X509SVIDUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_X509SVIDUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *X509SVIDUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_X509SVIDUpdate.Merge(m, src)
}
func (m *X509SVIDUpdate) XXX_Size() int {
	return m.Size()
}
func (m *X509SVIDUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_X509SVIDUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_X509SVIDUpdate proto.InternalMessageInfo

func (m *X509SVIDUpdate) GetSvids() map[string]*X509SVID {
	if m != nil {
		return m.Svids
	}
	return nil
}

func (m *X509SVIDUpdate) GetRegistrationEntries() []*RegistrationEntry {
	if m != nil {
		return m.RegistrationEntries
	}
	return nil
}

func (m *X509SVIDUpdate) GetBundles() map[string]*Bundle {
	if m != nil {
		return m.Bundles
	}
	return nil
}

// Represents a request to attest the node.
type AttestRequest struct {
	// A type which contains attestation data for specific platform.
	AttestationData *AttestationData `protobuf:"bytes,1,opt,name=attestation_data,json=attestationData,proto3" json:"attestation_data,omitempty"`
	// Certificate signing request.
	Csr []byte `protobuf:"bytes,2,opt,name=csr,proto3" json:"csr,omitempty"`
	// Attestation challenge response
	Response []byte `protobuf:"bytes,3,opt,name=response,proto3" json:"response,omitempty"`
}

func (m *AttestRequest) Reset()      { *m = AttestRequest{} }
func (*AttestRequest) ProtoMessage() {}
func (*AttestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_612fe91d1919e776, []int{2}
}
func (m *AttestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestRequest.Merge(m, src)
}
func (m *AttestRequest) XXX_Size() int {
	return m.Size()
}
func (m *AttestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttestRequest proto.InternalMessageInfo

func (m *AttestRequest) GetAttestationData() *AttestationData {
	if m != nil {
		return m.AttestationData
	}
	return nil
}

func (m *AttestRequest) GetCsr() []byte {
	if m != nil {
		return m.Csr
	}
	return nil
}

func (m *AttestRequest) GetResponse() []byte {
	if m != nil {
		return m.Response
	}
	return nil
}

// Represents a response that contains  map of signed SVIDs and an array of
// all current Registration Entries which are relevant to the caller SPIFFE ID
type AttestResponse struct {
	// It includes a map of signed SVIDs and an array of all current
	// Registration Entries which are relevant to the caller SPIFFE ID.
	SvidUpdate *X509SVIDUpdate `protobuf:"bytes,1,opt,name=svid_update,json=svidUpdate,proto3" json:"svid_update,omitempty"`
	// This is a challenge issued by the server to the node. If populated, the
	// node is expected to respond with another AttestRequest with the response.
	// This field is mutually exclusive with the update field.
	Challenge []byte `protobuf:"bytes,2,opt,name=challenge,proto3" json:"challenge,omitempty"`
}

func (m *AttestResponse) Reset()      { *m = AttestResponse{} }
func (*AttestResponse) ProtoMessage() {}
func (*AttestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_612fe91d1919e776, []int{3}
}
func (m *AttestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestResponse.Merge(m, src)
}
func (m *AttestResponse) XXX_Size() int {
	return m.Size()
}
func (m *AttestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AttestResponse proto.InternalMessageInfo

func (m *AttestResponse) GetSvidUpdate() *X509SVIDUpdate {
	if m != nil {
		return m.SvidUpdate
	}
	return nil
}

func (m *AttestResponse) GetChallenge() []byte {
	if m != nil {
		return m.Challenge
	}
	return nil
}

// Represents an empty message
type Empty struct {
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_612fe91d1919e776, []int{4}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

// A type which contains attestation data for specific platform.
type AttestationData struct {
	// Type of attestation to perform.
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// The attestation data.
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *AttestationData) Reset()      { *m = AttestationData{} }
func (*AttestationData) ProtoMessage() {}
func (*AttestationData) Descriptor() ([]byte, []int) {
	return fileDescriptor_612fe91d1919e776, []int{5}
}
func (m *AttestationData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestationData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestationData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestationData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestationData.Merge(m, src)
}
func (m *AttestationData) XXX_Size() int {
	return m.Size()
}
func (m *AttestationData) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestationData.DiscardUnknown(m)
}

var xxx_messageInfo_AttestationData proto.InternalMessageInfo

func (m *AttestationData) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AttestationData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// A type which describes the conditions under which a registration
// entry is matched.
type Selector struct {
	// A selector type represents the type of attestation used in attesting
	// the entity (Eg: AWS, K8).
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// The value to be attested.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Selector) Reset()      { *m = Selector{} }
func (*Selector) ProtoMessage() {}
func (*Selector) Descriptor() ([]byte, []int) {
	return fileDescriptor_612fe91d1919e776, []int{6}
}
func (m *Selector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Selector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Selector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Selector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Selector.Merge(m, src)
}
func (m *Selector) XXX_Size() int {
	return m.Size()
}
func (m *Selector) XXX_DiscardUnknown() {
	xxx_messageInfo_Selector.DiscardUnknown(m)
}

var xxx_messageInfo_Selector proto.InternalMessageInfo

func (m *Selector) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Selector) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Represents a type with a list of Selector.
type Selectors struct {
	// A list of Selector.
	Entries []*Selector `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (m *Selectors) Reset()      { *m = Selectors{} }
func (*Selectors) ProtoMessage() {}
func (*Selectors) Descriptor() ([]byte, []int) {
	return fileDescriptor_612fe91d1919e776, []int{7}
}
func (m *Selectors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Selectors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Selectors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Selectors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Selectors.Merge(m, src)
}
func (m *Selectors) XXX_Size() int {
	return m.Size()
}
func (m *Selectors) XXX_DiscardUnknown() {
	xxx_messageInfo_Selectors.DiscardUnknown(m)
}

var xxx_messageInfo_Selectors proto.InternalMessageInfo

func (m *Selectors) GetEntries() []*Selector {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Represents an attested SPIRE agent
type AttestedNode struct {
	// Node SPIFFE ID
	SpiffeId string `protobuf:"bytes,1,opt,name=spiffe_id,json=spiffeId,proto3" json:"spiffe_id,omitempty"`
	// Attestation data type
	AttestationDataType string `protobuf:"bytes,2,opt,name=attestation_data_type,json=attestationDataType,proto3" json:"attestation_data_type,omitempty"`
	// Node certificate serial number
	CertSerialNumber string `protobuf:"bytes,3,opt,name=cert_serial_number,json=certSerialNumber,proto3" json:"cert_serial_number,omitempty"`
	// Node certificate not_after (seconds since unix epoch)
	CertNotAfter int64 `protobuf:"varint,4,opt,name=cert_not_after,json=certNotAfter,proto3" json:"cert_not_after,omitempty"`
}

func (m *AttestedNode) Reset()      { *m = AttestedNode{} }
func (*AttestedNode) ProtoMessage() {}
func (*AttestedNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_612fe91d1919e776, []int{8}
}
func (m *AttestedNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestedNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestedNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestedNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestedNode.Merge(m, src)
}
func (m *AttestedNode) XXX_Size() int {
	return m.Size()
}
func (m *AttestedNode) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestedNode.DiscardUnknown(m)
}

var xxx_messageInfo_AttestedNode proto.InternalMessageInfo

func (m *AttestedNode) GetSpiffeId() string {
	if m != nil {
		return m.SpiffeId
	}
	return ""
}

func (m *AttestedNode) GetAttestationDataType() string {
	if m != nil {
		return m.AttestationDataType
	}
	return ""
}

func (m *AttestedNode) GetCertSerialNumber() string {
	if m != nil {
		return m.CertSerialNumber
	}
	return ""
}

func (m *AttestedNode) GetCertNotAfter() int64 {
	if m != nil {
		return m.CertNotAfter
	}
	return 0
}

// This is a curated record that the Server uses to set up and
// manage the various registered nodes and workloads that are controlled by it.
type RegistrationEntry struct {
	// A list of selectors.
	Selectors []*Selector `protobuf:"bytes,1,rep,name=selectors,proto3" json:"selectors,omitempty"`
	// The SPIFFE ID of an entity that is authorized to attest the validity
	// of a selector
	ParentId string `protobuf:"bytes,2,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty"`
	// The SPIFFE ID is a structured string used to identify a resource or
	// caller. It is defined as a URI comprising a “trust domain” and an
	// associated path.
	SpiffeId string `protobuf:"bytes,3,opt,name=spiffe_id,json=spiffeId,proto3" json:"spiffe_id,omitempty"`
	// Time to live.
	Ttl int32 `protobuf:"varint,4,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// A list of federated trust domain SPIFFE IDs.
	FederatesWith []string `protobuf:"bytes,5,rep,name=federates_with,json=federatesWith,proto3" json:"federates_with,omitempty"`
	// Entry ID
	EntryId string `protobuf:"bytes,6,opt,name=entry_id,json=entryId,proto3" json:"entry_id,omitempty"`
	// Whether or not the workload is an admin workload. Admin workloads
	// can use their SVID's to authenticate with the Registration API, for
	// example.
	Admin bool `protobuf:"varint,7,opt,name=admin,proto3" json:"admin,omitempty"`
	// To enable signing CA CSR in upstream spire server
	Downstream bool `protobuf:"varint,8,opt,name=downstream,proto3" json:"downstream,omitempty"`
	// Expiration of this entry
	Expiry int64 `protobuf:"varint,9,opt,name=expiry,proto3" json:"expiry,omitempty"`
}

func (m *RegistrationEntry) Reset()      { *m = RegistrationEntry{} }
func (*RegistrationEntry) ProtoMessage() {}
func (*RegistrationEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_612fe91d1919e776, []int{9}
}
func (m *RegistrationEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegistrationEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegistrationEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegistrationEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegistrationEntry.Merge(m, src)
}
func (m *RegistrationEntry) XXX_Size() int {
	return m.Size()
}
func (m *RegistrationEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_RegistrationEntry.DiscardUnknown(m)
}

var xxx_messageInfo_RegistrationEntry proto.InternalMessageInfo

func (m *RegistrationEntry) GetSelectors() []*Selector {
	if m != nil {
		return m.Selectors
	}
	return nil
}

func (m *RegistrationEntry) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *RegistrationEntry) GetSpiffeId() string {
	if m != nil {
		return m.SpiffeId
	}
	return ""
}

func (m *RegistrationEntry) GetTtl() int32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *RegistrationEntry) GetFederatesWith() []string {
	if m != nil {
		return m.FederatesWith
	}
	return nil
}

func (m *RegistrationEntry) GetEntryId() string {
	if m != nil {
		return m.EntryId
	}
	return ""
}

func (m *RegistrationEntry) GetAdmin() bool {
	if m != nil {
		return m.Admin
	}
	return false
}

func (m *RegistrationEntry) GetDownstream() bool {
	if m != nil {
		return m.Downstream
	}
	return false
}

func (m *RegistrationEntry) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

// A list of registration entries.
type RegistrationEntries struct {
	// A list of RegistrationEntry.
	Entries []*RegistrationEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (m *RegistrationEntries) Reset()      { *m = RegistrationEntries{} }
func (*RegistrationEntries) ProtoMessage() {}
func (*RegistrationEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_612fe91d1919e776, []int{10}
}
func (m *RegistrationEntries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegistrationEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegistrationEntries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegistrationEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegistrationEntries.Merge(m, src)
}
func (m *RegistrationEntries) XXX_Size() int {
	return m.Size()
}
func (m *RegistrationEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_RegistrationEntries.DiscardUnknown(m)
}

var xxx_messageInfo_RegistrationEntries proto.InternalMessageInfo

func (m *RegistrationEntries) GetEntries() []*RegistrationEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Certificate represents a ASN.1/DER encoded X509 certificate
type Certificate struct {
	// Certificate in der format
	DerBytes []byte `protobuf:"bytes,1,opt,name=der_bytes,json=derBytes,proto3" json:"der_bytes,omitempty"`
}

func (m *Certificate) Reset()      { *m = Certificate{} }
func (*Certificate) ProtoMessage() {}
func (*Certificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_612fe91d1919e776, []int{11}
}
func (m *Certificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Certificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Certificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Certificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Certificate.Merge(m, src)
}
func (m *Certificate) XXX_Size() int {
	return m.Size()
}
func (m *Certificate) XXX_DiscardUnknown() {
	xxx_messageInfo_Certificate.DiscardUnknown(m)
}

var xxx_messageInfo_Certificate proto.InternalMessageInfo

func (m *Certificate) GetDerBytes() []byte {
	if m != nil {
		return m.DerBytes
	}
	return nil
}

// PublicKey represents a PKIX encoded public key
type PublicKey struct {
	// PKIX encoded key data
	PkixBytes []byte `protobuf:"bytes,1,opt,name=pkix_bytes,json=pkixBytes,proto3" json:"pkix_bytes,omitempty"`
	// key identifier
	Kid string `protobuf:"bytes,2,opt,name=kid,proto3" json:"kid,omitempty"`
	// not after (seconds since unix epoch, 0 means "never expires")
	NotAfter int64 `protobuf:"varint,3,opt,name=not_after,json=notAfter,proto3" json:"not_after,omitempty"`
}

func (m *PublicKey) Reset()      { *m = PublicKey{} }
func (*PublicKey) ProtoMessage() {}
func (*PublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_612fe91d1919e776, []int{12}
}
func (m *PublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKey.Merge(m, src)
}
func (m *PublicKey) XXX_Size() int {
	return m.Size()
}
func (m *PublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKey proto.InternalMessageInfo

func (m *PublicKey) GetPkixBytes() []byte {
	if m != nil {
		return m.PkixBytes
	}
	return nil
}

func (m *PublicKey) GetKid() string {
	if m != nil {
		return m.Kid
	}
	return ""
}

func (m *PublicKey) GetNotAfter() int64 {
	if m != nil {
		return m.NotAfter
	}
	return 0
}

// Trust domain bundle
type Bundle struct {
	// the SPIFFE ID of the trust domain the bundle belongs to
	TrustDomainId string `protobuf:"bytes,1,opt,name=trust_domain_id,json=trustDomainId,proto3" json:"trust_domain_id,omitempty"`
	// list of root CA certificates
	RootCas []*Certificate `protobuf:"bytes,2,rep,name=root_cas,json=rootCas,proto3" json:"root_cas,omitempty"`
	// list of JWT signing keys
	JwtSigningKeys []*PublicKey `protobuf:"bytes,3,rep,name=jwt_signing_keys,json=jwtSigningKeys,proto3" json:"jwt_signing_keys,omitempty"`
}

func (m *Bundle) Reset()      { *m = Bundle{} }
func (*Bundle) ProtoMessage() {}
func (*Bundle) Descriptor() ([]byte, []int) {
	return fileDescriptor_612fe91d1919e776, []int{13}
}
func (m *Bundle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bundle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bundle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bundle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bundle.Merge(m, src)
}
func (m *Bundle) XXX_Size() int {
	return m.Size()
}
func (m *Bundle) XXX_DiscardUnknown() {
	xxx_messageInfo_Bundle.DiscardUnknown(m)
}

var xxx_messageInfo_Bundle proto.InternalMessageInfo

func (m *Bundle) GetTrustDomainId() string {
	if m != nil {
		return m.TrustDomainId
	}
	return ""
}

func (m *Bundle) GetRootCas() []*Certificate {
	if m != nil {
		return m.RootCas
	}
	return nil
}

func (m *Bundle) GetJwtSigningKeys() []*PublicKey {
	if m != nil {
		return m.JwtSigningKeys
	}
	return nil
}

func init() {
	proto.RegisterType((*X509SVID)(nil), "spire.api.node.X509SVID")
	proto.RegisterType((*X509SVIDUpdate)(nil), "spire.api.node.X509SVIDUpdate")
	proto.RegisterMapType((map[string]*Bundle)(nil), "spire.api.node.X509SVIDUpdate.BundlesEntry")
	proto.RegisterMapType((map[string]*X509SVID)(nil), "spire.api.node.X509SVIDUpdate.SvidsEntry")
	proto.RegisterType((*AttestRequest)(nil), "spire.api.node.AttestRequest")
	proto.RegisterType((*AttestResponse)(nil), "spire.api.node.AttestResponse")
	proto.RegisterType((*Empty)(nil), "spire.api.node.Empty")
	proto.RegisterType((*AttestationData)(nil), "spire.api.node.AttestationData")
	proto.RegisterType((*Selector)(nil), "spire.api.node.Selector")
	proto.RegisterType((*Selectors)(nil), "spire.api.node.Selectors")
	proto.RegisterType((*AttestedNode)(nil), "spire.api.node.AttestedNode")
	proto.RegisterType((*RegistrationEntry)(nil), "spire.api.node.RegistrationEntry")
	proto.RegisterType((*RegistrationEntries)(nil), "spire.api.node.RegistrationEntries")
	proto.RegisterType((*Certificate)(nil), "spire.api.node.Certificate")
	proto.RegisterType((*PublicKey)(nil), "spire.api.node.PublicKey")
	proto.RegisterType((*Bundle)(nil), "spire.api.node.Bundle")
}

func init() {
	proto.RegisterFile("security/proto/providers/spire/node.proto", fileDescriptor_612fe91d1919e776)
}

var fileDescriptor_612fe91d1919e776 = []byte{
	// 970 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0x4d, 0x73, 0xdb, 0x44,
	0x18, 0xb6, 0xe2, 0x7c, 0x48, 0x6f, 0x12, 0x27, 0x6c, 0x4a, 0x47, 0x4d, 0xa8, 0x08, 0x1a, 0x60,
	0x5c, 0xe8, 0x38, 0x1d, 0x03, 0x1d, 0x5a, 0x0e, 0x99, 0x7c, 0xcd, 0x10, 0x32, 0x93, 0x61, 0xd6,
	0xe5, 0xf3, 0xa2, 0xd9, 0x58, 0x6f, 0x92, 0x6d, 0x1c, 0x49, 0xec, 0xae, 0x93, 0xea, 0xc6, 0x95,
	0x1b, 0x27, 0xfe, 0x02, 0x5c, 0x38, 0xf1, 0x27, 0x38, 0xe6, 0xd8, 0x23, 0x71, 0x2e, 0x1c, 0xfb,
	0x13, 0x98, 0xdd, 0x95, 0x62, 0x5b, 0x4d, 0x69, 0x2f, 0x9e, 0xd5, 0xb3, 0xef, 0xfb, 0xec, 0xf3,
	0x7e, 0x1a, 0xee, 0x49, 0xec, 0xf6, 0x05, 0x57, 0xf9, 0x5a, 0x26, 0x52, 0x95, 0xea, 0xdf, 0x33,
	0x1e, 0xa3, 0x90, 0x6b, 0x32, 0xe3, 0x02, 0xd7, 0x92, 0x34, 0xc6, 0x96, 0xb9, 0x22, 0x0d, 0x83,
	0xb4, 0x58, 0xc6, 0x5b, 0x1a, 0x0d, 0xbf, 0x04, 0xf7, 0xfb, 0xcf, 0x1e, 0x3c, 0xea, 0x7c, 0xbb,
	0xbb, 0x4d, 0xee, 0x02, 0x74, 0x51, 0xa8, 0xa8, 0x7b, 0xcc, 0x78, 0xe2, 0xd7, 0x57, 0x9d, 0xe6,
	0x1c, 0xf5, 0x34, 0xb2, 0xa5, 0x01, 0x7d, 0x8d, 0xcf, 0xb4, 0xb7, 0x8c, 0x98, 0xf2, 0x27, 0x56,
	0x9d, 0x66, 0x9d, 0x7a, 0x05, 0xb2, 0xa1, 0xc2, 0xdf, 0xea, 0xd0, 0x28, 0xa9, 0xbe, 0xc9, 0x62,
	0xa6, 0x90, 0xac, 0xc3, 0x94, 0x3c, 0xe3, 0xb1, 0xf4, 0x9d, 0xd5, 0x7a, 0x73, 0xb6, 0x7d, 0xaf,
	0x35, 0xfe, 0x78, 0x6b, 0xdc, 0xbc, 0xd5, 0xd1, 0xb6, 0x3b, 0x89, 0x12, 0x39, 0xb5, 0x7e, 0xe4,
	0x09, 0xdc, 0x12, 0x78, 0xc4, 0xa5, 0x12, 0x4c, 0xf1, 0x34, 0x89, 0x30, 0x51, 0x82, 0xa3, 0xf4,
	0xeb, 0x86, 0xef, 0xbd, 0x2a, 0x1f, 0x1d, 0xb1, 0xb5, 0x3c, 0x4b, 0xa2, 0x02, 0x71, 0x94, 0x64,
	0x07, 0x66, 0x0e, 0xfa, 0x49, 0xdc, 0x43, 0xe9, 0x4f, 0x19, 0xa2, 0x8f, 0x5f, 0x23, 0x6c, 0xd3,
	0x5a, 0x5b, 0xca, 0xd2, 0x77, 0x99, 0x02, 0x0c, 0x15, 0x93, 0x45, 0xa8, 0x9f, 0x60, 0xee, 0x3b,
	0xab, 0x4e, 0xd3, 0xa3, 0xfa, 0x48, 0x5a, 0x30, 0x75, 0xc6, 0x7a, 0x7d, 0x34, 0xa9, 0x9a, 0x6d,
	0xfb, 0xaf, 0x7a, 0x84, 0x5a, 0xb3, 0xc7, 0x13, 0x9f, 0x3b, 0xcb, 0x14, 0xe6, 0x46, 0x1f, 0xbb,
	0x81, 0xf5, 0xfe, 0x38, 0xeb, 0xed, 0x2a, 0xab, 0x75, 0x1f, 0xe1, 0x0c, 0x7f, 0x71, 0x60, 0x7e,
	0x43, 0x29, 0x94, 0x8a, 0xe2, 0x4f, 0x7d, 0x94, 0x8a, 0x7c, 0x05, 0x8b, 0xcc, 0x00, 0x36, 0xab,
	0x31, 0x53, 0xcc, 0x3c, 0x31, 0xdb, 0x7e, 0xb7, 0x4a, 0xb7, 0x31, 0xb4, 0xdb, 0x66, 0x8a, 0xd1,
	0x05, 0x36, 0x0e, 0x68, 0x85, 0x5d, 0x29, 0x8c, 0x9a, 0x39, 0xaa, 0x8f, 0x64, 0x19, 0x5c, 0x81,
	0x32, 0x4b, 0x13, 0x89, 0x45, 0x13, 0x5d, 0x7f, 0x87, 0x29, 0x34, 0x4a, 0x29, 0x16, 0x21, 0xeb,
	0x30, 0xab, 0x6b, 0x1d, 0xf5, 0x4d, 0xaa, 0x0b, 0x19, 0xc1, 0xff, 0x17, 0x84, 0x82, 0x76, 0x29,
	0x9a, 0xec, 0x1d, 0xf0, 0xba, 0xc7, 0xac, 0xd7, 0xc3, 0xe4, 0x08, 0x0b, 0x19, 0x43, 0x20, 0x9c,
	0x81, 0xa9, 0x9d, 0xd3, 0x4c, 0xe5, 0xe1, 0x23, 0x58, 0xa8, 0xc4, 0x42, 0x08, 0x4c, 0xaa, 0x3c,
	0xc3, 0x22, 0xbb, 0xe6, 0xac, 0x31, 0x93, 0x0e, 0x4b, 0x64, 0xce, 0xe1, 0xa7, 0xe0, 0x76, 0xb0,
	0x87, 0x5d, 0x95, 0x8a, 0x1b, 0x7d, 0x6e, 0x8d, 0x96, 0xc4, 0x2b, 0x52, 0x1f, 0xae, 0x83, 0x57,
	0x7a, 0x49, 0xd2, 0x86, 0x99, 0xb2, 0x77, 0xed, 0x2c, 0xbc, 0xd4, 0x0d, 0xa5, 0x2d, 0x2d, 0x0d,
	0xc3, 0xbf, 0x1c, 0x98, 0xb3, 0x92, 0x31, 0xde, 0x4f, 0x63, 0x24, 0x2b, 0xe0, 0xc9, 0x8c, 0x1f,
	0x1e, 0x62, 0xc4, 0xe3, 0x42, 0x80, 0x6b, 0x81, 0xdd, 0x98, 0xb4, 0xe1, 0xed, 0x6a, 0x4d, 0x23,
	0xa3, 0xd4, 0x8a, 0x5a, 0xaa, 0xd4, 0xed, 0x89, 0x16, 0x7e, 0x1f, 0x88, 0x19, 0x78, 0x89, 0x82,
	0xb3, 0x5e, 0x94, 0xf4, 0x4f, 0x0f, 0x50, 0x98, 0x9a, 0x79, 0x74, 0x51, 0xdf, 0x74, 0xcc, 0xc5,
	0xbe, 0xc1, 0xc9, 0xfb, 0xd0, 0x30, 0xd6, 0x49, 0xaa, 0x22, 0x76, 0xa8, 0x50, 0xf8, 0x93, 0x66,
	0x07, 0xcc, 0x69, 0x74, 0x3f, 0x55, 0x1b, 0x1a, 0x0b, 0x7f, 0x9f, 0x80, 0xb7, 0x5e, 0x9a, 0x43,
	0xf2, 0x10, 0x3c, 0x59, 0x26, 0xe3, 0xb5, 0x19, 0x18, 0x9a, 0xea, 0x90, 0x33, 0x26, 0x30, 0x51,
	0x3a, 0x64, 0x1b, 0x89, 0x6b, 0x81, 0xdd, 0x78, 0x3c, 0x1f, 0xf5, 0x4a, 0x3e, 0x16, 0xa1, 0xae,
	0x54, 0xcf, 0x48, 0x9c, 0xa2, 0xfa, 0x48, 0x3e, 0x80, 0xc6, 0x21, 0xc6, 0x28, 0x98, 0x42, 0x19,
	0x9d, 0x73, 0x75, 0x6c, 0xa6, 0xdf, 0xa3, 0xf3, 0xd7, 0xe8, 0x77, 0x5c, 0x1d, 0x93, 0x3b, 0xe0,
	0xea, 0x0a, 0xe4, 0x9a, 0x74, 0xda, 0x90, 0x9a, 0x8a, 0xe4, 0xbb, 0xb1, 0x2e, 0x34, 0x8b, 0x4f,
	0x79, 0xe2, 0xcf, 0xac, 0x3a, 0x4d, 0x97, 0xda, 0x0f, 0x12, 0x00, 0xc4, 0xe9, 0x79, 0x22, 0x95,
	0x40, 0x76, 0xea, 0xbb, 0xe6, 0x6a, 0x04, 0x21, 0xb7, 0x61, 0xda, 0x6c, 0xc9, 0xdc, 0xf7, 0x4c,
	0xbe, 0x8a, 0xaf, 0x90, 0xc2, 0x12, 0xbd, 0x61, 0x3b, 0x7d, 0x51, 0x6d, 0x95, 0x37, 0x58, 0x73,
	0xd7, 0x3d, 0xf3, 0x11, 0xcc, 0x6e, 0xa1, 0x50, 0xfc, 0x90, 0x77, 0xf5, 0x6c, 0xac, 0x80, 0x17,
	0xa3, 0x88, 0x0e, 0x72, 0x65, 0xd8, 0xcc, 0x2c, 0xc6, 0x28, 0x36, 0xf5, 0x77, 0xf8, 0x03, 0x78,
	0x5f, 0xf7, 0x0f, 0x7a, 0xbc, 0xbb, 0x87, 0xb9, 0x5e, 0xee, 0xd9, 0x09, 0x7f, 0x36, 0x66, 0xea,
	0x69, 0xc4, 0xd8, 0x9a, 0x3d, 0x74, 0x5d, 0x01, 0x7d, 0xd4, 0xd4, 0xc3, 0x46, 0xa8, 0x9b, 0xc0,
	0xdc, 0xa4, 0x6c, 0x82, 0x3f, 0x1d, 0x98, 0xb6, 0x8b, 0x88, 0x7c, 0x08, 0x0b, 0x4a, 0xf4, 0xa5,
	0x8a, 0xe2, 0xf4, 0x94, 0xf1, 0x64, 0xd8, 0xba, 0xf3, 0x06, 0xde, 0x36, 0xe8, 0x6e, 0x4c, 0x1e,
	0x82, 0x2b, 0xd2, 0x54, 0x45, 0x5d, 0x26, 0xfd, 0x09, 0x13, 0xf7, 0x4a, 0x35, 0xee, 0x91, 0xc8,
	0xe8, 0x8c, 0x36, 0xde, 0x62, 0x92, 0x6c, 0xc1, 0xe2, 0xd3, 0x73, 0x15, 0x49, 0x7e, 0x94, 0xf0,
	0xe4, 0x28, 0x3a, 0xc1, 0xbc, 0xfc, 0x7b, 0xb8, 0x53, 0xf5, 0xbf, 0x8e, 0x96, 0x36, 0x9e, 0x9e,
	0xab, 0x8e, 0xf5, 0xd8, 0xc3, 0x5c, 0xb6, 0x3b, 0x30, 0x69, 0x26, 0x6c, 0x0f, 0xa6, 0xed, 0xc4,
	0x91, 0xbb, 0x37, 0x2f, 0xc2, 0x62, 0x83, 0x2e, 0x07, 0xaf, 0xba, 0xb6, 0x5b, 0xad, 0xe9, 0x3c,
	0x70, 0x36, 0x1f, 0x5f, 0x5c, 0x06, 0xb5, 0xe7, 0x97, 0x41, 0xed, 0xc5, 0x65, 0xe0, 0xfc, 0x3c,
	0x08, 0x9c, 0x3f, 0x06, 0x81, 0xf3, 0xf7, 0x20, 0x70, 0x2e, 0x06, 0x81, 0xf3, 0xcf, 0x20, 0x70,
	0xfe, 0x1d, 0x04, 0xb5, 0x17, 0x83, 0xc0, 0xf9, 0xf5, 0x2a, 0xa8, 0x5d, 0x5c, 0x05, 0xb5, 0xe7,
	0x57, 0x41, 0xed, 0xc7, 0x49, 0x4d, 0x77, 0x30, 0x6d, 0xfe, 0xad, 0x3f, 0xf9, 0x2f, 0x00, 0x00,
	0xff, 0xff, 0x0f, 0x97, 0xdf, 0x1a, 0xda, 0x07, 0x00, 0x00,
}

func (this *X509SVID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*X509SVID)
	if !ok {
		that2, ok := that.(X509SVID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.CertChain, that1.CertChain) {
		return false
	}
	if this.ExpiresAt != that1.ExpiresAt {
		return false
	}
	return true
}
func (this *X509SVIDUpdate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*X509SVIDUpdate)
	if !ok {
		that2, ok := that.(X509SVIDUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Svids) != len(that1.Svids) {
		return false
	}
	for i := range this.Svids {
		if !this.Svids[i].Equal(that1.Svids[i]) {
			return false
		}
	}
	if len(this.RegistrationEntries) != len(that1.RegistrationEntries) {
		return false
	}
	for i := range this.RegistrationEntries {
		if !this.RegistrationEntries[i].Equal(that1.RegistrationEntries[i]) {
			return false
		}
	}
	if len(this.Bundles) != len(that1.Bundles) {
		return false
	}
	for i := range this.Bundles {
		if !this.Bundles[i].Equal(that1.Bundles[i]) {
			return false
		}
	}
	return true
}
func (this *AttestRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttestRequest)
	if !ok {
		that2, ok := that.(AttestRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AttestationData.Equal(that1.AttestationData) {
		return false
	}
	if !bytes.Equal(this.Csr, that1.Csr) {
		return false
	}
	if !bytes.Equal(this.Response, that1.Response) {
		return false
	}
	return true
}
func (this *AttestResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttestResponse)
	if !ok {
		that2, ok := that.(AttestResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SvidUpdate.Equal(that1.SvidUpdate) {
		return false
	}
	if !bytes.Equal(this.Challenge, that1.Challenge) {
		return false
	}
	return true
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *AttestationData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttestationData)
	if !ok {
		that2, ok := that.(AttestationData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *Selector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Selector)
	if !ok {
		that2, ok := that.(Selector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *Selectors) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Selectors)
	if !ok {
		that2, ok := that.(Selectors)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Entries) != len(that1.Entries) {
		return false
	}
	for i := range this.Entries {
		if !this.Entries[i].Equal(that1.Entries[i]) {
			return false
		}
	}
	return true
}
func (this *AttestedNode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttestedNode)
	if !ok {
		that2, ok := that.(AttestedNode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SpiffeId != that1.SpiffeId {
		return false
	}
	if this.AttestationDataType != that1.AttestationDataType {
		return false
	}
	if this.CertSerialNumber != that1.CertSerialNumber {
		return false
	}
	if this.CertNotAfter != that1.CertNotAfter {
		return false
	}
	return true
}
func (this *RegistrationEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegistrationEntry)
	if !ok {
		that2, ok := that.(RegistrationEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Selectors) != len(that1.Selectors) {
		return false
	}
	for i := range this.Selectors {
		if !this.Selectors[i].Equal(that1.Selectors[i]) {
			return false
		}
	}
	if this.ParentId != that1.ParentId {
		return false
	}
	if this.SpiffeId != that1.SpiffeId {
		return false
	}
	if this.Ttl != that1.Ttl {
		return false
	}
	if len(this.FederatesWith) != len(that1.FederatesWith) {
		return false
	}
	for i := range this.FederatesWith {
		if this.FederatesWith[i] != that1.FederatesWith[i] {
			return false
		}
	}
	if this.EntryId != that1.EntryId {
		return false
	}
	if this.Admin != that1.Admin {
		return false
	}
	if this.Downstream != that1.Downstream {
		return false
	}
	if this.Expiry != that1.Expiry {
		return false
	}
	return true
}
func (this *RegistrationEntries) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegistrationEntries)
	if !ok {
		that2, ok := that.(RegistrationEntries)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Entries) != len(that1.Entries) {
		return false
	}
	for i := range this.Entries {
		if !this.Entries[i].Equal(that1.Entries[i]) {
			return false
		}
	}
	return true
}
func (this *Certificate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Certificate)
	if !ok {
		that2, ok := that.(Certificate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DerBytes, that1.DerBytes) {
		return false
	}
	return true
}
func (this *PublicKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PublicKey)
	if !ok {
		that2, ok := that.(PublicKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.PkixBytes, that1.PkixBytes) {
		return false
	}
	if this.Kid != that1.Kid {
		return false
	}
	if this.NotAfter != that1.NotAfter {
		return false
	}
	return true
}
func (this *Bundle) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Bundle)
	if !ok {
		that2, ok := that.(Bundle)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TrustDomainId != that1.TrustDomainId {
		return false
	}
	if len(this.RootCas) != len(that1.RootCas) {
		return false
	}
	for i := range this.RootCas {
		if !this.RootCas[i].Equal(that1.RootCas[i]) {
			return false
		}
	}
	if len(this.JwtSigningKeys) != len(that1.JwtSigningKeys) {
		return false
	}
	for i := range this.JwtSigningKeys {
		if !this.JwtSigningKeys[i].Equal(that1.JwtSigningKeys[i]) {
			return false
		}
	}
	return true
}
func (this *X509SVID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&node.X509SVID{")
	s = append(s, "CertChain: "+fmt.Sprintf("%#v", this.CertChain)+",\n")
	s = append(s, "ExpiresAt: "+fmt.Sprintf("%#v", this.ExpiresAt)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *X509SVIDUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&node.X509SVIDUpdate{")
	keysForSvids := make([]string, 0, len(this.Svids))
	for k, _ := range this.Svids {
		keysForSvids = append(keysForSvids, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSvids)
	mapStringForSvids := "map[string]*X509SVID{"
	for _, k := range keysForSvids {
		mapStringForSvids += fmt.Sprintf("%#v: %#v,", k, this.Svids[k])
	}
	mapStringForSvids += "}"
	if this.Svids != nil {
		s = append(s, "Svids: "+mapStringForSvids+",\n")
	}
	if this.RegistrationEntries != nil {
		s = append(s, "RegistrationEntries: "+fmt.Sprintf("%#v", this.RegistrationEntries)+",\n")
	}
	keysForBundles := make([]string, 0, len(this.Bundles))
	for k, _ := range this.Bundles {
		keysForBundles = append(keysForBundles, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForBundles)
	mapStringForBundles := "map[string]*Bundle{"
	for _, k := range keysForBundles {
		mapStringForBundles += fmt.Sprintf("%#v: %#v,", k, this.Bundles[k])
	}
	mapStringForBundles += "}"
	if this.Bundles != nil {
		s = append(s, "Bundles: "+mapStringForBundles+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AttestRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&node.AttestRequest{")
	if this.AttestationData != nil {
		s = append(s, "AttestationData: "+fmt.Sprintf("%#v", this.AttestationData)+",\n")
	}
	s = append(s, "Csr: "+fmt.Sprintf("%#v", this.Csr)+",\n")
	s = append(s, "Response: "+fmt.Sprintf("%#v", this.Response)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AttestResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&node.AttestResponse{")
	if this.SvidUpdate != nil {
		s = append(s, "SvidUpdate: "+fmt.Sprintf("%#v", this.SvidUpdate)+",\n")
	}
	s = append(s, "Challenge: "+fmt.Sprintf("%#v", this.Challenge)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&node.Empty{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AttestationData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&node.AttestationData{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Selector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&node.Selector{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Selectors) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&node.Selectors{")
	if this.Entries != nil {
		s = append(s, "Entries: "+fmt.Sprintf("%#v", this.Entries)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AttestedNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&node.AttestedNode{")
	s = append(s, "SpiffeId: "+fmt.Sprintf("%#v", this.SpiffeId)+",\n")
	s = append(s, "AttestationDataType: "+fmt.Sprintf("%#v", this.AttestationDataType)+",\n")
	s = append(s, "CertSerialNumber: "+fmt.Sprintf("%#v", this.CertSerialNumber)+",\n")
	s = append(s, "CertNotAfter: "+fmt.Sprintf("%#v", this.CertNotAfter)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegistrationEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&node.RegistrationEntry{")
	if this.Selectors != nil {
		s = append(s, "Selectors: "+fmt.Sprintf("%#v", this.Selectors)+",\n")
	}
	s = append(s, "ParentId: "+fmt.Sprintf("%#v", this.ParentId)+",\n")
	s = append(s, "SpiffeId: "+fmt.Sprintf("%#v", this.SpiffeId)+",\n")
	s = append(s, "Ttl: "+fmt.Sprintf("%#v", this.Ttl)+",\n")
	s = append(s, "FederatesWith: "+fmt.Sprintf("%#v", this.FederatesWith)+",\n")
	s = append(s, "EntryId: "+fmt.Sprintf("%#v", this.EntryId)+",\n")
	s = append(s, "Admin: "+fmt.Sprintf("%#v", this.Admin)+",\n")
	s = append(s, "Downstream: "+fmt.Sprintf("%#v", this.Downstream)+",\n")
	s = append(s, "Expiry: "+fmt.Sprintf("%#v", this.Expiry)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegistrationEntries) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&node.RegistrationEntries{")
	if this.Entries != nil {
		s = append(s, "Entries: "+fmt.Sprintf("%#v", this.Entries)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Certificate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&node.Certificate{")
	s = append(s, "DerBytes: "+fmt.Sprintf("%#v", this.DerBytes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PublicKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&node.PublicKey{")
	s = append(s, "PkixBytes: "+fmt.Sprintf("%#v", this.PkixBytes)+",\n")
	s = append(s, "Kid: "+fmt.Sprintf("%#v", this.Kid)+",\n")
	s = append(s, "NotAfter: "+fmt.Sprintf("%#v", this.NotAfter)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Bundle) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&node.Bundle{")
	s = append(s, "TrustDomainId: "+fmt.Sprintf("%#v", this.TrustDomainId)+",\n")
	if this.RootCas != nil {
		s = append(s, "RootCas: "+fmt.Sprintf("%#v", this.RootCas)+",\n")
	}
	if this.JwtSigningKeys != nil {
		s = append(s, "JwtSigningKeys: "+fmt.Sprintf("%#v", this.JwtSigningKeys)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringNode(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NodeClient is the client API for Node service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NodeClient interface {
	// Attest the node, get base node SVID.
	Attest(ctx context.Context, opts ...grpc.CallOption) (Node_AttestClient, error)
}

type nodeClient struct {
	cc *grpc.ClientConn
}

func NewNodeClient(cc *grpc.ClientConn) NodeClient {
	return &nodeClient{cc}
}

func (c *nodeClient) Attest(ctx context.Context, opts ...grpc.CallOption) (Node_AttestClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Node_serviceDesc.Streams[0], "/spire.api.node.Node/Attest", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeAttestClient{stream}
	return x, nil
}

type Node_AttestClient interface {
	Send(*AttestRequest) error
	Recv() (*AttestResponse, error)
	grpc.ClientStream
}

type nodeAttestClient struct {
	grpc.ClientStream
}

func (x *nodeAttestClient) Send(m *AttestRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nodeAttestClient) Recv() (*AttestResponse, error) {
	m := new(AttestResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NodeServer is the server API for Node service.
type NodeServer interface {
	// Attest the node, get base node SVID.
	Attest(Node_AttestServer) error
}

func RegisterNodeServer(s *grpc.Server, srv NodeServer) {
	s.RegisterService(&_Node_serviceDesc, srv)
}

func _Node_Attest_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NodeServer).Attest(&nodeAttestServer{stream})
}

type Node_AttestServer interface {
	Send(*AttestResponse) error
	Recv() (*AttestRequest, error)
	grpc.ServerStream
}

type nodeAttestServer struct {
	grpc.ServerStream
}

func (x *nodeAttestServer) Send(m *AttestResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nodeAttestServer) Recv() (*AttestRequest, error) {
	m := new(AttestRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Node_serviceDesc = grpc.ServiceDesc{
	ServiceName: "spire.api.node.Node",
	HandlerType: (*NodeServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Attest",
			Handler:       _Node_Attest_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "security/proto/providers/spire/node.proto",
}

func (m *X509SVID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *X509SVID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ExpiresAt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNode(dAtA, i, uint64(m.ExpiresAt))
	}
	if len(m.CertChain) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.CertChain)))
		i += copy(dAtA[i:], m.CertChain)
	}
	return i, nil
}

func (m *X509SVIDUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *X509SVIDUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Svids) > 0 {
		for k, _ := range m.Svids {
			dAtA[i] = 0xa
			i++
			v := m.Svids[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovNode(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovNode(uint64(len(k))) + msgSize
			i = encodeVarintNode(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintNode(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintNode(dAtA, i, uint64(v.Size()))
				n1, err1 := v.MarshalTo(dAtA[i:])
				if err1 != nil {
					return 0, err1
				}
				i += n1
			}
		}
	}
	if len(m.RegistrationEntries) > 0 {
		for _, msg := range m.RegistrationEntries {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintNode(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Bundles) > 0 {
		for k, _ := range m.Bundles {
			dAtA[i] = 0x2a
			i++
			v := m.Bundles[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovNode(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovNode(uint64(len(k))) + msgSize
			i = encodeVarintNode(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintNode(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintNode(dAtA, i, uint64(v.Size()))
				n2, err2 := v.MarshalTo(dAtA[i:])
				if err2 != nil {
					return 0, err2
				}
				i += n2
			}
		}
	}
	return i, nil
}

func (m *AttestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AttestationData != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNode(dAtA, i, uint64(m.AttestationData.Size()))
		n3, err3 := m.AttestationData.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if len(m.Csr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.Csr)))
		i += copy(dAtA[i:], m.Csr)
	}
	if len(m.Response) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.Response)))
		i += copy(dAtA[i:], m.Response)
	}
	return i, nil
}

func (m *AttestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SvidUpdate != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNode(dAtA, i, uint64(m.SvidUpdate.Size()))
		n4, err4 := m.SvidUpdate.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if len(m.Challenge) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.Challenge)))
		i += copy(dAtA[i:], m.Challenge)
	}
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AttestationData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestationData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *Selector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Selector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *Selectors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Selectors) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNode(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AttestedNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestedNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SpiffeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.SpiffeId)))
		i += copy(dAtA[i:], m.SpiffeId)
	}
	if len(m.AttestationDataType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.AttestationDataType)))
		i += copy(dAtA[i:], m.AttestationDataType)
	}
	if len(m.CertSerialNumber) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.CertSerialNumber)))
		i += copy(dAtA[i:], m.CertSerialNumber)
	}
	if m.CertNotAfter != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNode(dAtA, i, uint64(m.CertNotAfter))
	}
	return i, nil
}

func (m *RegistrationEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegistrationEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Selectors) > 0 {
		for _, msg := range m.Selectors {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNode(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ParentId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.ParentId)))
		i += copy(dAtA[i:], m.ParentId)
	}
	if len(m.SpiffeId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.SpiffeId)))
		i += copy(dAtA[i:], m.SpiffeId)
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNode(dAtA, i, uint64(m.Ttl))
	}
	if len(m.FederatesWith) > 0 {
		for _, s := range m.FederatesWith {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.EntryId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.EntryId)))
		i += copy(dAtA[i:], m.EntryId)
	}
	if m.Admin {
		dAtA[i] = 0x38
		i++
		if m.Admin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Downstream {
		dAtA[i] = 0x40
		i++
		if m.Downstream {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Expiry != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNode(dAtA, i, uint64(m.Expiry))
	}
	return i, nil
}

func (m *RegistrationEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegistrationEntries) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNode(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Certificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Certificate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DerBytes) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.DerBytes)))
		i += copy(dAtA[i:], m.DerBytes)
	}
	return i, nil
}

func (m *PublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PkixBytes) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.PkixBytes)))
		i += copy(dAtA[i:], m.PkixBytes)
	}
	if len(m.Kid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.Kid)))
		i += copy(dAtA[i:], m.Kid)
	}
	if m.NotAfter != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNode(dAtA, i, uint64(m.NotAfter))
	}
	return i, nil
}

func (m *Bundle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bundle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TrustDomainId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNode(dAtA, i, uint64(len(m.TrustDomainId)))
		i += copy(dAtA[i:], m.TrustDomainId)
	}
	if len(m.RootCas) > 0 {
		for _, msg := range m.RootCas {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNode(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.JwtSigningKeys) > 0 {
		for _, msg := range m.JwtSigningKeys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintNode(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintNode(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *X509SVID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpiresAt != 0 {
		n += 1 + sovNode(uint64(m.ExpiresAt))
	}
	l = len(m.CertChain)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *X509SVIDUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Svids) > 0 {
		for k, v := range m.Svids {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovNode(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovNode(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovNode(uint64(mapEntrySize))
		}
	}
	if len(m.RegistrationEntries) > 0 {
		for _, e := range m.RegistrationEntries {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if len(m.Bundles) > 0 {
		for k, v := range m.Bundles {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovNode(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovNode(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovNode(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AttestRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttestationData != nil {
		l = m.AttestationData.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Csr)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Response)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *AttestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SvidUpdate != nil {
		l = m.SvidUpdate.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Challenge)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AttestationData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *Selector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *Selectors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	return n
}

func (m *AttestedNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpiffeId)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.AttestationDataType)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.CertSerialNumber)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.CertNotAfter != 0 {
		n += 1 + sovNode(uint64(m.CertNotAfter))
	}
	return n
}

func (m *RegistrationEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Selectors) > 0 {
		for _, e := range m.Selectors {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.SpiffeId)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Ttl != 0 {
		n += 1 + sovNode(uint64(m.Ttl))
	}
	if len(m.FederatesWith) > 0 {
		for _, s := range m.FederatesWith {
			l = len(s)
			n += 1 + l + sovNode(uint64(l))
		}
	}
	l = len(m.EntryId)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Admin {
		n += 2
	}
	if m.Downstream {
		n += 2
	}
	if m.Expiry != 0 {
		n += 1 + sovNode(uint64(m.Expiry))
	}
	return n
}

func (m *RegistrationEntries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	return n
}

func (m *Certificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DerBytes)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *PublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PkixBytes)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Kid)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.NotAfter != 0 {
		n += 1 + sovNode(uint64(m.NotAfter))
	}
	return n
}

func (m *Bundle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TrustDomainId)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if len(m.RootCas) > 0 {
		for _, e := range m.RootCas {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if len(m.JwtSigningKeys) > 0 {
		for _, e := range m.JwtSigningKeys {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	return n
}

func sovNode(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNode(x uint64) (n int) {
	return sovNode(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *X509SVID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&X509SVID{`,
		`ExpiresAt:` + fmt.Sprintf("%v", this.ExpiresAt) + `,`,
		`CertChain:` + fmt.Sprintf("%v", this.CertChain) + `,`,
		`}`,
	}, "")
	return s
}
func (this *X509SVIDUpdate) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRegistrationEntries := "[]*RegistrationEntry{"
	for _, f := range this.RegistrationEntries {
		repeatedStringForRegistrationEntries += strings.Replace(f.String(), "RegistrationEntry", "RegistrationEntry", 1) + ","
	}
	repeatedStringForRegistrationEntries += "}"
	keysForSvids := make([]string, 0, len(this.Svids))
	for k, _ := range this.Svids {
		keysForSvids = append(keysForSvids, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSvids)
	mapStringForSvids := "map[string]*X509SVID{"
	for _, k := range keysForSvids {
		mapStringForSvids += fmt.Sprintf("%v: %v,", k, this.Svids[k])
	}
	mapStringForSvids += "}"
	keysForBundles := make([]string, 0, len(this.Bundles))
	for k, _ := range this.Bundles {
		keysForBundles = append(keysForBundles, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForBundles)
	mapStringForBundles := "map[string]*Bundle{"
	for _, k := range keysForBundles {
		mapStringForBundles += fmt.Sprintf("%v: %v,", k, this.Bundles[k])
	}
	mapStringForBundles += "}"
	s := strings.Join([]string{`&X509SVIDUpdate{`,
		`Svids:` + mapStringForSvids + `,`,
		`RegistrationEntries:` + repeatedStringForRegistrationEntries + `,`,
		`Bundles:` + mapStringForBundles + `,`,
		`}`,
	}, "")
	return s
}
func (this *AttestRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AttestRequest{`,
		`AttestationData:` + strings.Replace(this.AttestationData.String(), "AttestationData", "AttestationData", 1) + `,`,
		`Csr:` + fmt.Sprintf("%v", this.Csr) + `,`,
		`Response:` + fmt.Sprintf("%v", this.Response) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AttestResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AttestResponse{`,
		`SvidUpdate:` + strings.Replace(this.SvidUpdate.String(), "X509SVIDUpdate", "X509SVIDUpdate", 1) + `,`,
		`Challenge:` + fmt.Sprintf("%v", this.Challenge) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func (this *AttestationData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AttestationData{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Selector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Selector{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Selectors) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEntries := "[]*Selector{"
	for _, f := range this.Entries {
		repeatedStringForEntries += strings.Replace(f.String(), "Selector", "Selector", 1) + ","
	}
	repeatedStringForEntries += "}"
	s := strings.Join([]string{`&Selectors{`,
		`Entries:` + repeatedStringForEntries + `,`,
		`}`,
	}, "")
	return s
}
func (this *AttestedNode) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AttestedNode{`,
		`SpiffeId:` + fmt.Sprintf("%v", this.SpiffeId) + `,`,
		`AttestationDataType:` + fmt.Sprintf("%v", this.AttestationDataType) + `,`,
		`CertSerialNumber:` + fmt.Sprintf("%v", this.CertSerialNumber) + `,`,
		`CertNotAfter:` + fmt.Sprintf("%v", this.CertNotAfter) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegistrationEntry) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSelectors := "[]*Selector{"
	for _, f := range this.Selectors {
		repeatedStringForSelectors += strings.Replace(f.String(), "Selector", "Selector", 1) + ","
	}
	repeatedStringForSelectors += "}"
	s := strings.Join([]string{`&RegistrationEntry{`,
		`Selectors:` + repeatedStringForSelectors + `,`,
		`ParentId:` + fmt.Sprintf("%v", this.ParentId) + `,`,
		`SpiffeId:` + fmt.Sprintf("%v", this.SpiffeId) + `,`,
		`Ttl:` + fmt.Sprintf("%v", this.Ttl) + `,`,
		`FederatesWith:` + fmt.Sprintf("%v", this.FederatesWith) + `,`,
		`EntryId:` + fmt.Sprintf("%v", this.EntryId) + `,`,
		`Admin:` + fmt.Sprintf("%v", this.Admin) + `,`,
		`Downstream:` + fmt.Sprintf("%v", this.Downstream) + `,`,
		`Expiry:` + fmt.Sprintf("%v", this.Expiry) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegistrationEntries) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEntries := "[]*RegistrationEntry{"
	for _, f := range this.Entries {
		repeatedStringForEntries += strings.Replace(f.String(), "RegistrationEntry", "RegistrationEntry", 1) + ","
	}
	repeatedStringForEntries += "}"
	s := strings.Join([]string{`&RegistrationEntries{`,
		`Entries:` + repeatedStringForEntries + `,`,
		`}`,
	}, "")
	return s
}
func (this *Certificate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Certificate{`,
		`DerBytes:` + fmt.Sprintf("%v", this.DerBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PublicKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PublicKey{`,
		`PkixBytes:` + fmt.Sprintf("%v", this.PkixBytes) + `,`,
		`Kid:` + fmt.Sprintf("%v", this.Kid) + `,`,
		`NotAfter:` + fmt.Sprintf("%v", this.NotAfter) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Bundle) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRootCas := "[]*Certificate{"
	for _, f := range this.RootCas {
		repeatedStringForRootCas += strings.Replace(f.String(), "Certificate", "Certificate", 1) + ","
	}
	repeatedStringForRootCas += "}"
	repeatedStringForJwtSigningKeys := "[]*PublicKey{"
	for _, f := range this.JwtSigningKeys {
		repeatedStringForJwtSigningKeys += strings.Replace(f.String(), "PublicKey", "PublicKey", 1) + ","
	}
	repeatedStringForJwtSigningKeys += "}"
	s := strings.Join([]string{`&Bundle{`,
		`TrustDomainId:` + fmt.Sprintf("%v", this.TrustDomainId) + `,`,
		`RootCas:` + repeatedStringForRootCas + `,`,
		`JwtSigningKeys:` + repeatedStringForJwtSigningKeys + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringNode(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *X509SVID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: X509SVID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: X509SVID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertChain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertChain = append(m.CertChain[:0], dAtA[iNdEx:postIndex]...)
			if m.CertChain == nil {
				m.CertChain = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *X509SVIDUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: X509SVIDUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: X509SVIDUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Svids == nil {
				m.Svids = make(map[string]*X509SVID)
			}
			var mapkey string
			var mapvalue *X509SVID
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthNode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthNode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthNode
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthNode
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &X509SVID{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Svids[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrationEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegistrationEntries = append(m.RegistrationEntries, &RegistrationEntry{})
			if err := m.RegistrationEntries[len(m.RegistrationEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bundles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bundles == nil {
				m.Bundles = make(map[string]*Bundle)
			}
			var mapkey string
			var mapvalue *Bundle
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthNode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthNode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthNode
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthNode
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Bundle{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Bundles[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttestationData == nil {
				m.AttestationData = &AttestationData{}
			}
			if err := m.AttestationData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Csr = append(m.Csr[:0], dAtA[iNdEx:postIndex]...)
			if m.Csr == nil {
				m.Csr = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response[:0], dAtA[iNdEx:postIndex]...)
			if m.Response == nil {
				m.Response = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvidUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SvidUpdate == nil {
				m.SvidUpdate = &X509SVIDUpdate{}
			}
			if err := m.SvidUpdate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenge = append(m.Challenge[:0], dAtA[iNdEx:postIndex]...)
			if m.Challenge == nil {
				m.Challenge = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestationData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestationData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestationData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Selector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Selector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Selector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Selectors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Selectors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Selectors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Selector{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestedNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestedNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestedNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpiffeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpiffeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationDataType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationDataType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertSerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertSerialNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertNotAfter", wireType)
			}
			m.CertNotAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertNotAfter |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegistrationEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegistrationEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegistrationEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selectors = append(m.Selectors, &Selector{})
			if err := m.Selectors[len(m.Selectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpiffeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpiffeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FederatesWith", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FederatesWith = append(m.FederatesWith, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Downstream", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Downstream = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegistrationEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegistrationEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegistrationEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &RegistrationEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Certificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Certificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Certificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerBytes = append(m.DerBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.DerBytes == nil {
				m.DerBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkixBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PkixBytes = append(m.PkixBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.PkixBytes == nil {
				m.PkixBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotAfter", wireType)
			}
			m.NotAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotAfter |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bundle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bundle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bundle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustDomainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustDomainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootCas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootCas = append(m.RootCas, &Certificate{})
			if err := m.RootCas[len(m.RootCas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JwtSigningKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JwtSigningKeys = append(m.JwtSigningKeys, &PublicKey{})
			if err := m.JwtSigningKeys[len(m.JwtSigningKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNode(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNode
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNode
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthNode
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNode
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNode(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthNode
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNode = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNode   = fmt.Errorf("proto: integer overflow")
)
