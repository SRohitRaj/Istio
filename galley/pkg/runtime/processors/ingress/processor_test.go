//  Copyright 2019 Istio Authors
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ingress

import (
	"encoding/json"
	"reflect"
	"sort"
	"strings"
	"testing"

	"github.com/gogo/protobuf/jsonpb"
	"github.com/gogo/protobuf/proto"
	"k8s.io/api/extensions/v1beta1"
	"k8s.io/apimachinery/pkg/util/intstr"

	"istio.io/istio/galley/pkg/metadata"
	"istio.io/istio/galley/pkg/runtime/processing"
	"istio.io/istio/galley/pkg/runtime/resource"
)

var ingressInfo resource.Info

func init() {
	b := resource.NewSchemaBuilder()
	b.Register("type.googleapis.com/k8s.io.api.extensions.v1beta1.IngressSpec")
	s := b.Build()
	ingressInfo = s.Get("type.googleapis.com/k8s.io.api.extensions.v1beta1.IngressSpec")
}

type testData struct {
	name string

	// input events for tests
	events []resource.Event

	// expected resource entries
	expectedVS []string
	expectedGW []string
}

var tests = []testData{
	{
		name:       "empty",
		expectedGW: []string{},
		expectedVS: []string{},
	},

	{
		name: "empty gateway",
		events: []resource.Event{
			added("ns1", "i1", "v1", &v1beta1.IngressSpec{}),
		},
		expectedGW: []string{`
{
  "metadata": {
    "name": "istio-system/i1-istio-autogenerated-k8s-ingress",
    "createTime": "0001-01-01T00:00:00Z",
    "version": "v1"
  },
  "body": {
    "@type": "type.googleapis.com/istio.networking.v1alpha3.Gateway",
    "servers": [
      {
        "port": {
          "number": 80,
          "protocol": "HTTP",
          "name": "http-80-i-i1-ns1"
        },
        "hosts": [
          "*"
        ]
      }
    ],
    "selector": {
      "istio": "ingress"
    }
  }
}
`,
		},
		expectedVS: []string{},
	},

	{
		name: "ingress with tls",
		events: []resource.Event{
			added("ns1", "i1", "v1", &v1beta1.IngressSpec{
				TLS: []v1beta1.IngressTLS{
					{
						Hosts:      []string{"foo"},
						SecretName: "sssh",
					},
				},
			}),
		},
		expectedGW: []string{
			`
{
  "metadata": {
    "name": "istio-system/i1-istio-autogenerated-k8s-ingress",
    "createTime": "0001-01-01T00:00:00Z",
    "version": "v1"
  },
  "body": {
    "@type": "type.googleapis.com/istio.networking.v1alpha3.Gateway",
    "servers": [
      {
        "port": {
          "number": 443,
          "protocol": "HTTPS",
          "name": "https-443-i-i1-ns1"
        },
        "hosts": [
          "foo"
        ],
        "tls": {
          "mode": "SIMPLE",
          "serverCertificate": "/etc/istio/ingress-certs/tls.crt",
          "privateKey": "/etc/istio/ingress-certs/tls.key",
          "caCertificates": "/etc/istio/ingress-certs/root-cert.pem"
        }
      },
      {
        "port": {
          "number": 80,
          "protocol": "HTTP",
          "name": "http-80-i-i1-ns1"
        },
        "hosts": [
          "*"
        ]
      }
    ],
    "selector": {
      "istio": "ingress"
    }
  }
}
`,
		},
		expectedVS: []string{},
	},

	{
		name: "gateway with tls no tls host",
		events: []resource.Event{
			added("ns1", "i1", "v1", &v1beta1.IngressSpec{
				TLS: []v1beta1.IngressTLS{
					{
						SecretName: "sssh",
					},
				},
			}),
		},
		expectedGW: []string{
			`
{
	"metadata": {
		"name": "istio-system/i1-istio-autogenerated-k8s-ingress",
		"createTime": "0001-01-01T00:00:00Z",
		"version": "v1"
	},
	"body": {
		"@type": "type.googleapis.com/istio.networking.v1alpha3.Gateway",
		"servers": [
		{
			"port": {
				"number": 443,
				"protocol": "HTTPS",
				"name": "https-443-i-i1-ns1"
			},
			"hosts": [
				"*"
		],
			"tls": {
			"mode": "SIMPLE",
			"serverCertificate": "/etc/istio/ingress-certs/tls.crt",
			"privateKey": "/etc/istio/ingress-certs/tls.key",
			"caCertificates": "/etc/istio/ingress-certs/root-cert.pem"
		}
		},
		{
			"port": {
				"number": 80,
				"protocol": "HTTP",
				"name": "http-80-i-i1-ns1"
			},
			"hosts": [
				"*"
		]
		}
	],
		"selector": {
		"istio": "ingress"
	}
	}
}`,
		},
		expectedVS: []string{},
	},

	{
		name: "ingress with rule",
		events: []resource.Event{
			added("ns1", "i1", "v1", &v1beta1.IngressSpec{
				Backend: &v1beta1.IngressBackend{
					ServiceName: "svc1",
					ServicePort: intstr.FromInt(81),
				},
				Rules: []v1beta1.IngressRule{
					{
						Host: "hostfoo",
						IngressRuleValue: v1beta1.IngressRuleValue{
							HTTP: &v1beta1.HTTPIngressRuleValue{
								Paths: []v1beta1.HTTPIngressPath{
									{
										Backend: v1beta1.IngressBackend{
											ServicePort: intstr.FromInt(82),
											ServiceName: "svc2",
										},
										Path: "/baz",
									},
								},
							},
						},
					},
				},
			}),
		},
		expectedGW: []string{
			`
{
	"metadata": {
		"name": "istio-system/i1-istio-autogenerated-k8s-ingress",
		"createTime": "0001-01-01T00:00:00Z",
		"version": "v1"
	},
	"body": {
		"@type": "type.googleapis.com/istio.networking.v1alpha3.Gateway",
		"servers": [
		{
			"port": {
				"number": 80,
				"protocol": "HTTP",
				"name": "http-80-i-i1-ns1"
			},
			"hosts": [
				"*"
		]
		}
	],
		"selector": {
		"istio": "ingress"
	}
	}
}`,
		},
		expectedVS: []string{
			`
{
	"metadata": {
		"name": "istio-system/hostfoo-i1-istio-autogenerated-k8s-ingress",
		"createTime": "0001-01-01T00:00:00Z",
		"version": "ns1/i1-v1"
	},
	"body": {
		"@type": "type.googleapis.com/istio.networking.v1alpha3.VirtualService",
		"hosts": [
			"hostfoo"
		],
		"gateways": [
			"istio-autogenerated-k8s-ingress"
		],
		"http": [
			{
				"match": [
					{
						"uri": {
							"exact": "/baz"
						}
					}
				],
				"route": [
					{
						"destination": {
							"host": "svc2.ns1.svc.dmnsfx",
							"port": {
								"number": 82
							}
						},
						"weight": 100
					}
				]
			}
		]
	}
}`,
		},
	},

	{
		name: "ingress with rule and missing host",
		events: []resource.Event{
			added("ns1", "i1", "v1", &v1beta1.IngressSpec{
				Backend: &v1beta1.IngressBackend{
					ServiceName: "svc1",
					ServicePort: intstr.FromInt(81),
				},
				Rules: []v1beta1.IngressRule{
					{
						Host: "",
						IngressRuleValue: v1beta1.IngressRuleValue{
							HTTP: &v1beta1.HTTPIngressRuleValue{
								Paths: []v1beta1.HTTPIngressPath{
									{
										Backend: v1beta1.IngressBackend{
											ServicePort: intstr.FromInt(82),
											ServiceName: "svc2",
										},
										Path: "/baz",
									},
								},
							},
						},
					},
				},
			}),
		},
		expectedGW: []string{
			`
{
	"metadata": {
		"name": "istio-system/i1-istio-autogenerated-k8s-ingress",
		"createTime": "0001-01-01T00:00:00Z",
		"version": "v1"
	},
	"body": {
		"@type": "type.googleapis.com/istio.networking.v1alpha3.Gateway",
		"servers": [
		{
			"port": {
				"number": 80,
				"protocol": "HTTP",
				"name": "http-80-i-i1-ns1"
			},
			"hosts": [
				"*"
		]
		}
	],
		"selector": {
		"istio": "ingress"
	}
	}
}`,
		},
		expectedVS: []string{
			`
{
	"metadata": {
		"name": "istio-system/-i1-istio-autogenerated-k8s-ingress",
		"createTime": "0001-01-01T00:00:00Z",
		"version": "ns1/i1-v1"
	},
	"body": {
		"@type": "type.googleapis.com/istio.networking.v1alpha3.VirtualService",
		"hosts": [
			"*"
		],
		"gateways": [
			"istio-autogenerated-k8s-ingress"
		],
		"http": [
			{
				"match": [
					{
						"uri": {
							"exact": "/baz"
						}
					}
				],
				"route": [
					{
						"destination": {
							"host": "svc2.ns1.svc.dmnsfx",
							"port": {
								"number": 82
							}
						},
						"weight": 100
					}
				]
			}
		]
	}
}`,
		},
	},

	{
		name: "ingress with rule no http",
		events: []resource.Event{
			added("ns1", "i1", "v1", &v1beta1.IngressSpec{
				Backend: &v1beta1.IngressBackend{
					ServiceName: "svc1",
					ServicePort: intstr.FromInt(81),
				},
				Rules: []v1beta1.IngressRule{
					{
						Host:             "hostfoo",
						IngressRuleValue: v1beta1.IngressRuleValue{},
					},
				},
			}),
		},
		expectedGW: []string{
			`
{
	"metadata": {
		"name": "istio-system/i1-istio-autogenerated-k8s-ingress",
		"createTime": "0001-01-01T00:00:00Z",
		"version": "v1"
	},
	"body": {
		"@type": "type.googleapis.com/istio.networking.v1alpha3.Gateway",
		"servers": [
		{
			"port": {
				"number": 80,
				"protocol": "HTTP",
				"name": "http-80-i-i1-ns1"
			},
			"hosts": [
				"*"
		]
		}
	],
		"selector": {
		"istio": "ingress"
	}
	}
}`,
		},
		expectedVS: []string{},
	},

	{
		name: "ingress merge on host",
		events: []resource.Event{
			added("ns1", "i1", "v1", &v1beta1.IngressSpec{
				Backend: &v1beta1.IngressBackend{
					ServiceName: "svc1",
					ServicePort: intstr.FromInt(81),
				},
				Rules: []v1beta1.IngressRule{
					{
						Host: "hostfoo",
						IngressRuleValue: v1beta1.IngressRuleValue{
							HTTP: &v1beta1.HTTPIngressRuleValue{
								Paths: []v1beta1.HTTPIngressPath{
									{
										Backend: v1beta1.IngressBackend{
											ServicePort: intstr.FromInt(82),
											ServiceName: "svc2",
										},
										Path: "/baz/*",
									},
								},
							},
						},
					},
				},
			}),
			added("ns2", "i2", "v2", &v1beta1.IngressSpec{
				Backend: &v1beta1.IngressBackend{
					ServiceName: "svc3",
					ServicePort: intstr.FromInt(81),
				},
				Rules: []v1beta1.IngressRule{
					{
						Host: "hostfoo",
						IngressRuleValue: v1beta1.IngressRuleValue{
							HTTP: &v1beta1.HTTPIngressRuleValue{
								Paths: []v1beta1.HTTPIngressPath{
									{
										Backend: v1beta1.IngressBackend{
											ServicePort: intstr.FromInt(82),
											ServiceName: "svc4",
										},
										Path: "/par.*",
									},
								},
							},
						},
					},
				},
			}),
		},
		expectedGW: []string{
			`{
		"metadata": {
			"name": "istio-system/i1-istio-autogenerated-k8s-ingress",
			"createTime": "0001-01-01T00:00:00Z",
			"version": "v1"
		},
		"body": {
			"@type": "type.googleapis.com/istio.networking.v1alpha3.Gateway",
			"servers": [
			{
				"port": {
					"number": 80,
					"protocol": "HTTP",
					"name": "http-80-i-i1-ns1"
				},
				"hosts": [
					"*"
				]
			}
			],
			"selector": {
				"istio": "ingress"
			}
		}
	}`,
			`
{
	"metadata": {
		"name": "istio-system/i2-istio-autogenerated-k8s-ingress",
		"createTime": "0001-01-01T00:00:00Z",
		"version": "v2"
	},
	"body": {
		"@type": "type.googleapis.com/istio.networking.v1alpha3.Gateway",
		"servers": [
		{
			"port": {
				"number": 80,
				"protocol": "HTTP",
				"name": "http-80-i-i2-ns2"
			},
			"hosts": [
				"*"
			]
		}
		],
		"selector": {
			"istio": "ingress"
		}
	}
}`,
		},
		expectedVS: []string{
			`
{
  "metadata": {
    "name": "istio-system/hostfoo-i1-istio-autogenerated-k8s-ingress",
    "createTime": "0001-01-01T00:00:00Z",
    "version": "ns1/i1-v1-ns2/i2-v2"
  },
  "body": {
    "@type": "type.googleapis.com/istio.networking.v1alpha3.VirtualService",
    "hosts": [
      "hostfoo"
    ],
    "gateways": [
      "istio-autogenerated-k8s-ingress"
    ],
    "http": [
      {
        "match": [
          {
            "uri": {
              "prefix": "/baz"
            }
          }
        ],
        "route": [
          {
            "destination": {
              "host": "svc2.ns1.svc.dmnsfx",
              "port": {
                "number": 82
              }
            },
            "weight": 100
          }
        ]
      },
      {
        "match": [
          {
            "uri": {
              "prefix": "/par"
            }
          }
        ],
        "route": [
          {
            "destination": {
              "host": "svc4.ns2.svc.dmnsfx",
              "port": {
                "number": 82
              }
            },
            "weight": 100
          }
        ]
      }
    ]
  }
}`,
		},
	},

	{
		name: "ingress merge on host with a later update",
		events: []resource.Event{
			added("ns1", "i1", "v1", &v1beta1.IngressSpec{
				Backend: &v1beta1.IngressBackend{
					ServiceName: "svc1",
					ServicePort: intstr.FromInt(81),
				},
				Rules: []v1beta1.IngressRule{
					{
						Host: "hostfoo",
						IngressRuleValue: v1beta1.IngressRuleValue{
							HTTP: &v1beta1.HTTPIngressRuleValue{
								Paths: []v1beta1.HTTPIngressPath{
									{
										Backend: v1beta1.IngressBackend{
											ServicePort: intstr.FromInt(82),
											ServiceName: "svc2",
										},
										Path: "/baz/*",
									},
								},
							},
						},
					},
				},
			}),
			added("ns2", "i2", "v2", &v1beta1.IngressSpec{
				Backend: &v1beta1.IngressBackend{
					ServiceName: "svc3",
					ServicePort: intstr.FromInt(81),
				},
				Rules: []v1beta1.IngressRule{
					{
						Host: "hostfoo2",
						IngressRuleValue: v1beta1.IngressRuleValue{
							HTTP: &v1beta1.HTTPIngressRuleValue{
								Paths: []v1beta1.HTTPIngressPath{
									{
										Backend: v1beta1.IngressBackend{
											ServicePort: intstr.FromInt(82),
											ServiceName: "svc4",
										},
										Path: "/par.*",
									},
								},
							},
						},
					},
				},
			}),
			updated("ns2", "i2", "v3", &v1beta1.IngressSpec{
				Backend: &v1beta1.IngressBackend{
					ServiceName: "svc3",
					ServicePort: intstr.FromInt(81),
				},
				Rules: []v1beta1.IngressRule{
					{
						Host: "hostfoo",
						IngressRuleValue: v1beta1.IngressRuleValue{
							HTTP: &v1beta1.HTTPIngressRuleValue{
								Paths: []v1beta1.HTTPIngressPath{
									{
										Backend: v1beta1.IngressBackend{
											ServicePort: intstr.FromInt(82),
											ServiceName: "svc4",
										},
										Path: "/par.*",
									},
								},
							},
						},
					},
				},
			}),
		},
		expectedGW: []string{
			`{
		"metadata": {
			"name": "istio-system/i1-istio-autogenerated-k8s-ingress",
			"createTime": "0001-01-01T00:00:00Z",
			"version": "v1"
		},
		"body": {
			"@type": "type.googleapis.com/istio.networking.v1alpha3.Gateway",
			"servers": [
			{
				"port": {
					"number": 80,
					"protocol": "HTTP",
					"name": "http-80-i-i1-ns1"
				},
				"hosts": [
					"*"
				]
			}
			],
			"selector": {
				"istio": "ingress"
			}
		}
	}`,
			`
{
	"metadata": {
		"name": "istio-system/i2-istio-autogenerated-k8s-ingress",
		"createTime": "0001-01-01T00:00:00Z",
		"version": "v3"
	},
	"body": {
		"@type": "type.googleapis.com/istio.networking.v1alpha3.Gateway",
		"servers": [
		{
			"port": {
				"number": 80,
				"protocol": "HTTP",
				"name": "http-80-i-i2-ns2"
			},
			"hosts": [
				"*"
			]
		}
		],
		"selector": {
			"istio": "ingress"
		}
	}
}`,
		},
		expectedVS: []string{
			`
{
  "metadata": {
    "name": "istio-system/hostfoo-i1-istio-autogenerated-k8s-ingress",
    "createTime": "0001-01-01T00:00:00Z",
    "version": "ns1/i1-v1-ns2/i2-v3"
  },
  "body": {
    "@type": "type.googleapis.com/istio.networking.v1alpha3.VirtualService",
    "hosts": [
      "hostfoo"
    ],
    "gateways": [
      "istio-autogenerated-k8s-ingress"
    ],
    "http": [
      {
        "match": [
          {
            "uri": {
              "prefix": "/baz"
            }
          }
        ],
        "route": [
          {
            "destination": {
              "host": "svc2.ns1.svc.dmnsfx",
              "port": {
                "number": 82
              }
            },
            "weight": 100
          }
        ]
      },
      {
        "match": [
          {
            "uri": {
              "prefix": "/par"
            }
          }
        ],
        "route": [
          {
            "destination": {
              "host": "svc4.ns2.svc.dmnsfx",
              "port": {
                "number": 82
              }
            },
            "weight": 100
          }
        ]
      }
    ]
  }
}`,
		},
	},

	{
		name: "ingress with rule after add delete",
		events: []resource.Event{
			added("ns1", "i1", "v1", &v1beta1.IngressSpec{
				Backend: &v1beta1.IngressBackend{
					ServiceName: "svc1",
					ServicePort: intstr.FromInt(81),
				},
				Rules: []v1beta1.IngressRule{
					{
						Host: "hostfoo",
						IngressRuleValue: v1beta1.IngressRuleValue{
							HTTP: &v1beta1.HTTPIngressRuleValue{
								Paths: []v1beta1.HTTPIngressPath{
									{
										Backend: v1beta1.IngressBackend{
											ServicePort: intstr.FromInt(82),
											ServiceName: "svc2",
										},
										Path: "/baz",
									},
								},
							},
						},
					},
				},
			}),
			added("ns2", "i2", "v2", &v1beta1.IngressSpec{
				Backend: &v1beta1.IngressBackend{
					ServiceName: "svc3",
					ServicePort: intstr.FromInt(81),
				},
				Rules: []v1beta1.IngressRule{
					{
						Host: "hostfoo2",
						IngressRuleValue: v1beta1.IngressRuleValue{
							HTTP: &v1beta1.HTTPIngressRuleValue{
								Paths: []v1beta1.HTTPIngressPath{
									{
										Backend: v1beta1.IngressBackend{
											ServicePort: intstr.FromInt(82),
											ServiceName: "svc4",
										},
										Path: "/par.*",
									},
								},
							},
						},
					},
				},
			}),
			deleted("ns2", "i2", "v3"),
		},
		expectedGW: []string{
			`
{
	"metadata": {
		"name": "istio-system/i1-istio-autogenerated-k8s-ingress",
		"createTime": "0001-01-01T00:00:00Z",
		"version": "v1"
	},
	"body": {
		"@type": "type.googleapis.com/istio.networking.v1alpha3.Gateway",
		"servers": [
		{
			"port": {
				"number": 80,
				"protocol": "HTTP",
				"name": "http-80-i-i1-ns1"
			},
			"hosts": [
				"*"
		]
		}
	],
		"selector": {
		"istio": "ingress"
	}
	}
}`,
		},
		expectedVS: []string{
			`
{
	"metadata": {
		"name": "istio-system/hostfoo-i1-istio-autogenerated-k8s-ingress",
		"createTime": "0001-01-01T00:00:00Z",
		"version": "ns1/i1-v1"
	},
	"body": {
		"@type": "type.googleapis.com/istio.networking.v1alpha3.VirtualService",
		"hosts": [
			"hostfoo"
		],
		"gateways": [
			"istio-autogenerated-k8s-ingress"
		],
		"http": [
			{
				"match": [
					{
						"uri": {
							"exact": "/baz"
						}
					}
				],
				"route": [
					{
						"destination": {
							"host": "svc2.ns1.svc.dmnsfx",
							"port": {
								"number": 82
							}
						},
						"weight": 100
					}
				]
			}
		]
	}
}`,
		},
	},
}

func added(ns, name, version string, i proto.Message) resource.Event {
	return resource.Event{
		Kind: resource.Added,
		Entry: resource.Entry{
			ID: resource.VersionedKey{
				Version: resource.Version(version),
				Key: resource.Key{
					TypeURL:  metadata.IngressSpec.TypeURL,
					FullName: resource.FullNameFromNamespaceAndName(ns, name),
				},
			},
			Item: i,
		},
	}
}

func updated(ns, name, version string, i proto.Message) resource.Event {
	return resource.Event{
		Kind: resource.Updated,
		Entry: resource.Entry{
			ID: resource.VersionedKey{
				Version: resource.Version(version),
				Key: resource.Key{
					TypeURL:  metadata.IngressSpec.TypeURL,
					FullName: resource.FullNameFromNamespaceAndName(ns, name),
				},
			},
			Item: i,
		},
	}
}

func deleted(ns, name, version string) resource.Event {
	return resource.Event{
		Kind: resource.Deleted,
		Entry: resource.Entry{
			ID: resource.VersionedKey{
				Version: resource.Version(version),
				Key: resource.Key{
					TypeURL:  metadata.IngressSpec.TypeURL,
					FullName: resource.FullNameFromNamespaceAndName(ns, name),
				},
			},
		},
	}
}

func TestIngressPipeline(t *testing.T) {
	for _, td := range tests {
		t.Run(td.name, func(t *testing.T) {
			b := processing.NewGraphBuilder()
			cfg := &Config{
				DomainSuffix: "dmnsfx",
			}
			AddProcessor(cfg, b)
			p := b.Build()

			for _, e := range td.events {
				p.Handle(e)
			}

			sn := p.Snapshot([]resource.TypeURL{metadata.Gateway.TypeURL, metadata.VirtualService.TypeURL})
			actualGW := sn.Resources(metadata.Gateway.TypeURL.String())
			actualVS := sn.Resources(metadata.VirtualService.TypeURL.String())

			sort.Slice(actualGW, func(i, j int) bool {
				return strings.Compare(actualGW[i].Metadata.Name, actualGW[j].Metadata.Name) < 0
			})

			sort.Slice(actualVS, func(i, j int) bool {
				return strings.Compare(actualVS[i].Metadata.Name, actualVS[j].Metadata.Name) < 0
			})

			var actualGateways []string
			for _, gw := range actualGW {
				m := jsonpb.Marshaler{Indent: "  "}
				s, err := m.MarshalToString(gw)
				if err != nil {
					t.Fatalf("Unexpected error while marshalling: %v", err)
				}

				actualGateways = append(actualGateways, s)
			}

			var actualVirtualServices []string
			for _, gw := range actualVS {
				m := jsonpb.Marshaler{Indent: "  "}
				s, err := m.MarshalToString(gw)
				if err != nil {
					t.Fatalf("Unexpected error while marshalling: %v", err)
				}
				actualVirtualServices = append(actualVirtualServices, s)
			}

			if !compare(t, actualGateways, td.expectedGW) {
				t.Fatalf("Gateway mismatch: got:\n%+v\nwanted:\n%+v", actualGateways, td.expectedGW)
			}

			if !compare(t, actualVirtualServices, td.expectedVS) {
				t.Fatalf("VirtualService mismatch: got:\n%+v\nwanted:\n%+v", actualVirtualServices, td.expectedVS)
			}
		})
	}
}

func compare(t *testing.T, actual, expected []string) bool {
	if len(actual) != len(expected) {
		return false
	}

	for i := 0; i < len(actual); i++ {
		act := make(map[string]interface{})
		err := json.Unmarshal([]byte(actual[i]), &act)
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		exp := make(map[string]interface{})
		err = json.Unmarshal([]byte(expected[i]), &exp)
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if !reflect.DeepEqual(act, exp) {
			return false
		}
	}

	return true
}
